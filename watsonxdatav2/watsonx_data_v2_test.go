/**
 * (C) Copyright IBM Corp. 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package watsonxdatav2_test

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/IBM/watsonxdata-go-sdk/watsonxdatav2"
	"github.com/go-openapi/strfmt"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
)

var _ = Describe(`WatsonxDataV2`, func() {
	var testServer *httptest.Server
	Describe(`Service constructor tests`, func() {
		It(`Instantiate service client`, func() {
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
				Authenticator: &core.NoAuthAuthenticator{},
			})
			Expect(watsonxDataService).ToNot(BeNil())
			Expect(serviceErr).To(BeNil())
		})
		It(`Instantiate service client with error: Invalid URL`, func() {
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
				URL: "{BAD_URL_STRING",
			})
			Expect(watsonxDataService).To(BeNil())
			Expect(serviceErr).ToNot(BeNil())
		})
		It(`Instantiate service client with error: Invalid Auth`, func() {
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
				URL: "https://watsonxdatav2/api",
				Authenticator: &core.BasicAuthenticator{
					Username: "",
					Password: "",
				},
			})
			Expect(watsonxDataService).To(BeNil())
			Expect(serviceErr).ToNot(BeNil())
		})
	})
	Describe(`Service constructor tests using external config`, func() {
		Context(`Using external config, construct service client instances`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"WATSONX_DATA_URL": "https://watsonxdatav2/api",
				"WATSONX_DATA_AUTH_TYPE": "noauth",
			}

			It(`Create service client using external config successfully`, func() {
				SetTestEnvironment(testEnvironment)
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
				})
				Expect(watsonxDataService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				ClearTestEnvironment(testEnvironment)

				clone := watsonxDataService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != watsonxDataService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(watsonxDataService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(watsonxDataService.Service.Options.Authenticator))
			})
			It(`Create service client using external config and set url from constructor successfully`, func() {
				SetTestEnvironment(testEnvironment)
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
					URL: "https://testService/api",
				})
				Expect(watsonxDataService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)

				clone := watsonxDataService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != watsonxDataService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(watsonxDataService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(watsonxDataService.Service.Options.Authenticator))
			})
			It(`Create service client using external config and set url programatically successfully`, func() {
				SetTestEnvironment(testEnvironment)
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
				})
				err := watsonxDataService.SetServiceURL("https://testService/api")
				Expect(err).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService.Service.GetServiceURL()).To(Equal("https://testService/api"))
				ClearTestEnvironment(testEnvironment)

				clone := watsonxDataService.Clone()
				Expect(clone).ToNot(BeNil())
				Expect(clone.Service != watsonxDataService.Service).To(BeTrue())
				Expect(clone.GetServiceURL()).To(Equal(watsonxDataService.GetServiceURL()))
				Expect(clone.Service.Options.Authenticator).To(Equal(watsonxDataService.Service.Options.Authenticator))
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid Auth`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"WATSONX_DATA_URL": "https://watsonxdatav2/api",
				"WATSONX_DATA_AUTH_TYPE": "someOtherAuth",
			}

			SetTestEnvironment(testEnvironment)
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
			})

			It(`Instantiate service client with error`, func() {
				Expect(watsonxDataService).To(BeNil())
				Expect(serviceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
		Context(`Using external config, construct service client instances with error: Invalid URL`, func() {
			// Map containing environment variables used in testing.
			var testEnvironment = map[string]string{
				"WATSONX_DATA_AUTH_TYPE":   "NOAuth",
			}

			SetTestEnvironment(testEnvironment)
			watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2UsingExternalConfig(&watsonxdatav2.WatsonxDataV2Options{
				URL: "{BAD_URL_STRING",
			})

			It(`Instantiate service client with error`, func() {
				Expect(watsonxDataService).To(BeNil())
				Expect(serviceErr).ToNot(BeNil())
				ClearTestEnvironment(testEnvironment)
			})
		})
	})
	Describe(`Regional endpoint tests`, func() {
		It(`GetServiceURLForRegion(region string)`, func() {
			var url string
			var err error
			url, err = watsonxdatav2.GetServiceURLForRegion("INVALID_REGION")
			Expect(url).To(BeEmpty())
			Expect(err).ToNot(BeNil())
			fmt.Fprintf(GinkgoWriter, "Expected error: %s\n", err.Error())
		})
	})
	Describe(`ListBucketRegistrations(listBucketRegistrationsOptions *ListBucketRegistrationsOptions) - Operation response error`, func() {
		listBucketRegistrationsPath := "/bucket_registrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListBucketRegistrations with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListBucketRegistrations(listBucketRegistrationsOptions *ListBucketRegistrationsOptions)`, func() {
		listBucketRegistrationsPath := "/bucket_registrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"bucket_registrations": [{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "tags": ["Tags"]}]}`)
				}))
			})
			It(`Invoke ListBucketRegistrations successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListBucketRegistrationsWithContext(ctx, listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListBucketRegistrationsWithContext(ctx, listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"bucket_registrations": [{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "tags": ["Tags"]}]}`)
				}))
			})
			It(`Invoke ListBucketRegistrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListBucketRegistrations with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListBucketRegistrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := new(watsonxdatav2.ListBucketRegistrationsOptions)
				listBucketRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListBucketRegistrations(listBucketRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateBucketRegistration(createBucketRegistrationOptions *CreateBucketRegistrationOptions) - Operation response error`, func() {
		createBucketRegistrationPath := "/bucket_registrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createBucketRegistrationPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateBucketRegistration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateBucketRegistration(createBucketRegistrationOptions *CreateBucketRegistrationOptions)`, func() {
		createBucketRegistrationPath := "/bucket_registrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createBucketRegistrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke CreateBucketRegistration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateBucketRegistrationWithContext(ctx, createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateBucketRegistrationWithContext(ctx, createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createBucketRegistrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke CreateBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateBucketRegistration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateBucketRegistrationOptions model with no property values
				createBucketRegistrationOptionsModelNew := new(watsonxdatav2.CreateBucketRegistrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the CreateBucketRegistrationOptions model
				createBucketRegistrationOptionsModel := new(watsonxdatav2.CreateBucketRegistrationOptions)
				createBucketRegistrationOptionsModel.BucketDetails = bucketDetailsModel
				createBucketRegistrationOptionsModel.BucketType = core.StringPtr("ibm_cos")
				createBucketRegistrationOptionsModel.Description = core.StringPtr("COS bucket for customer data")
				createBucketRegistrationOptionsModel.ManagedBy = core.StringPtr("ibm")
				createBucketRegistrationOptionsModel.AssociatedCatalog = bucketCatalogModel
				createBucketRegistrationOptionsModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.Region = core.StringPtr("us-south")
				createBucketRegistrationOptionsModel.Tags = []string{"bucket-tag1", "bucket-tag2"}
				createBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateBucketRegistration(createBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetBucketRegistration(getBucketRegistrationOptions *GetBucketRegistrationOptions) - Operation response error`, func() {
		getBucketRegistrationPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getBucketRegistrationPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetBucketRegistration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetBucketRegistration(getBucketRegistrationOptions *GetBucketRegistrationOptions)`, func() {
		getBucketRegistrationPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getBucketRegistrationPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke GetBucketRegistration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetBucketRegistrationWithContext(ctx, getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetBucketRegistrationWithContext(ctx, getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getBucketRegistrationPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke GetBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetBucketRegistration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetBucketRegistration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetBucketRegistrationOptions model with no property values
				getBucketRegistrationOptionsModelNew := new(watsonxdatav2.GetBucketRegistrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetBucketRegistrationOptions model
				getBucketRegistrationOptionsModel := new(watsonxdatav2.GetBucketRegistrationOptions)
				getBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetBucketRegistration(getBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeregisterBucket(deregisterBucketOptions *DeregisterBucketOptions)`, func() {
		deregisterBucketPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deregisterBucketPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeregisterBucket successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeregisterBucket(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeregisterBucketOptions model
				deregisterBucketOptionsModel := new(watsonxdatav2.DeregisterBucketOptions)
				deregisterBucketOptionsModel.BucketID = core.StringPtr("testString")
				deregisterBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deregisterBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeregisterBucket(deregisterBucketOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeregisterBucket with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeregisterBucketOptions model
				deregisterBucketOptionsModel := new(watsonxdatav2.DeregisterBucketOptions)
				deregisterBucketOptionsModel.BucketID = core.StringPtr("testString")
				deregisterBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deregisterBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeregisterBucket(deregisterBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeregisterBucketOptions model with no property values
				deregisterBucketOptionsModelNew := new(watsonxdatav2.DeregisterBucketOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeregisterBucket(deregisterBucketOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateBucketRegistration(updateBucketRegistrationOptions *UpdateBucketRegistrationOptions) - Operation response error`, func() {
		updateBucketRegistrationPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateBucketRegistrationPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateBucketRegistration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateBucketRegistration(updateBucketRegistrationOptions *UpdateBucketRegistrationOptions)`, func() {
		updateBucketRegistrationPath := "/bucket_registrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateBucketRegistrationPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke UpdateBucketRegistration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateBucketRegistrationWithContext(ctx, updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateBucketRegistrationWithContext(ctx, updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateBucketRegistrationPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "bucket_details": {"access_key": "b9cbf248ea5c4c96947e64407108559j", "bucket_name": "sample-bucket", "endpoint": "https://s3.<region>.cloud-object-storage.appdomain.cloud/", "secret_key": "13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87"}, "bucket_display_name": "sample-bucket-displayname", "bucket_id": "samplebucket123", "bucket_type": "ibm_cos", "created_by": "<username>@<domain>.com", "created_on": "1686120645", "description": "COS bucket for customer data", "managed_by": "ibm", "region": "us-south", "state": "active", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke UpdateBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateBucketRegistration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateBucketRegistrationOptions model with no property values
				updateBucketRegistrationOptionsModelNew := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateBucketRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

				// Construct an instance of the BucketRegistrationPatch model
				bucketRegistrationPatchModel := new(watsonxdatav2.BucketRegistrationPatch)
				bucketRegistrationPatchModel.BucketDetails = bucketDetailsModel
				bucketRegistrationPatchModel.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
				bucketRegistrationPatchModel.Description = core.StringPtr("COS bucket for customer data")
				bucketRegistrationPatchModel.Tags = []string{"testbucket", "userbucket"}
				bucketRegistrationPatchModelAsPatch, asPatchErr := bucketRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateBucketRegistrationOptions model
				updateBucketRegistrationOptionsModel := new(watsonxdatav2.UpdateBucketRegistrationOptions)
				updateBucketRegistrationOptionsModel.BucketID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Body = bucketRegistrationPatchModelAsPatch
				updateBucketRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateBucketRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateBucketRegistration(updateBucketRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateActivateBucket(createActivateBucketOptions *CreateActivateBucketOptions) - Operation response error`, func() {
		createActivateBucketPath := "/bucket_registrations/testString/activate"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createActivateBucketPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateActivateBucket with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateActivateBucket(createActivateBucketOptions *CreateActivateBucketOptions)`, func() {
		createActivateBucketPath := "/bucket_registrations/testString/activate"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createActivateBucketPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke CreateActivateBucket successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateActivateBucketWithContext(ctx, createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateActivateBucketWithContext(ctx, createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createActivateBucketPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke CreateActivateBucket successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateActivateBucket(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateActivateBucket with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateActivateBucketOptions model with no property values
				createActivateBucketOptionsModelNew := new(watsonxdatav2.CreateActivateBucketOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateActivateBucket successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateActivateBucketOptions model
				createActivateBucketOptionsModel := new(watsonxdatav2.CreateActivateBucketOptions)
				createActivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				createActivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createActivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateActivateBucket(createActivateBucketOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteDeactivateBucket(deleteDeactivateBucketOptions *DeleteDeactivateBucketOptions)`, func() {
		deleteDeactivateBucketPath := "/bucket_registrations/testString/deactivate"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteDeactivateBucketPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteDeactivateBucket successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteDeactivateBucket(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteDeactivateBucketOptions model
				deleteDeactivateBucketOptionsModel := new(watsonxdatav2.DeleteDeactivateBucketOptions)
				deleteDeactivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				deleteDeactivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDeactivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteDeactivateBucket(deleteDeactivateBucketOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteDeactivateBucket with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteDeactivateBucketOptions model
				deleteDeactivateBucketOptionsModel := new(watsonxdatav2.DeleteDeactivateBucketOptions)
				deleteDeactivateBucketOptionsModel.BucketID = core.StringPtr("testString")
				deleteDeactivateBucketOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDeactivateBucketOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteDeactivateBucket(deleteDeactivateBucketOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteDeactivateBucketOptions model with no property values
				deleteDeactivateBucketOptionsModelNew := new(watsonxdatav2.DeleteDeactivateBucketOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteDeactivateBucket(deleteDeactivateBucketOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListBucketObjects(listBucketObjectsOptions *ListBucketObjectsOptions) - Operation response error`, func() {
		listBucketObjectsPath := "/bucket_registrations/testString/objects"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketObjectsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListBucketObjects with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListBucketObjects(listBucketObjectsOptions *ListBucketObjectsOptions)`, func() {
		listBucketObjectsPath := "/bucket_registrations/testString/objects"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"objects": ["Objects"]}`)
				}))
			})
			It(`Invoke ListBucketObjects successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListBucketObjectsWithContext(ctx, listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListBucketObjectsWithContext(ctx, listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listBucketObjectsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"objects": ["Objects"]}`)
				}))
			})
			It(`Invoke ListBucketObjects successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListBucketObjects(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListBucketObjects with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListBucketObjectsOptions model with no property values
				listBucketObjectsOptionsModelNew := new(watsonxdatav2.ListBucketObjectsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListBucketObjects successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListBucketObjectsOptions model
				listBucketObjectsOptionsModel := new(watsonxdatav2.ListBucketObjectsOptions)
				listBucketObjectsOptionsModel.BucketID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listBucketObjectsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListBucketObjects(listBucketObjectsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListDatabaseRegistrations(listDatabaseRegistrationsOptions *ListDatabaseRegistrationsOptions) - Operation response error`, func() {
		listDatabaseRegistrationsPath := "/database_registrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDatabaseRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListDatabaseRegistrations with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListDatabaseRegistrations(listDatabaseRegistrationsOptions *ListDatabaseRegistrationsOptions)`, func() {
		listDatabaseRegistrationsPath := "/database_registrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDatabaseRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"database_registrations": [{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "database_name": "new_database", "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "password": "samplepassword", "port": 4553, "sasl": true, "ssl": true, "tables": "kafka_table_name", "username": "sampleuser", "validate_server_certificate": true}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "description": "Description of the external Database", "tags": ["Tags"]}]}`)
				}))
			})
			It(`Invoke ListDatabaseRegistrations successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListDatabaseRegistrationsWithContext(ctx, listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListDatabaseRegistrationsWithContext(ctx, listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDatabaseRegistrationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"database_registrations": [{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "database_name": "new_database", "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "password": "samplepassword", "port": 4553, "sasl": true, "ssl": true, "tables": "kafka_table_name", "username": "sampleuser", "validate_server_certificate": true}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "description": "Description of the external Database", "tags": ["Tags"]}]}`)
				}))
			})
			It(`Invoke ListDatabaseRegistrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListDatabaseRegistrations with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListDatabaseRegistrations successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := new(watsonxdatav2.ListDatabaseRegistrationsOptions)
				listDatabaseRegistrationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDatabaseRegistrationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListDatabaseRegistrations(listDatabaseRegistrationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateDatabaseRegistration(createDatabaseRegistrationOptions *CreateDatabaseRegistrationOptions) - Operation response error`, func() {
		createDatabaseRegistrationPath := "/database_registrations"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDatabaseRegistrationPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateDatabaseRegistration with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateDatabaseRegistration(createDatabaseRegistrationOptions *CreateDatabaseRegistrationOptions)`, func() {
		createDatabaseRegistrationPath := "/database_registrations"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDatabaseRegistrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "database_name": "new_database", "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "password": "samplepassword", "port": 4553, "sasl": true, "ssl": true, "tables": "kafka_table_name", "username": "sampleuser", "validate_server_certificate": true}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "description": "Description of the external Database", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke CreateDatabaseRegistration successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateDatabaseRegistrationWithContext(ctx, createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateDatabaseRegistrationWithContext(ctx, createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDatabaseRegistrationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "database_name": "new_database", "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "password": "samplepassword", "port": 4553, "sasl": true, "ssl": true, "tables": "kafka_table_name", "username": "sampleuser", "validate_server_certificate": true}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "description": "Description of the external Database", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke CreateDatabaseRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateDatabaseRegistration with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateDatabaseRegistrationOptions model with no property values
				createDatabaseRegistrationOptionsModelNew := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateDatabaseRegistration successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsModel := new(watsonxdatav2.CreateDatabaseRegistrationOptions)
				createDatabaseRegistrationOptionsModel.DatabaseDisplayName = core.StringPtr("new_database")
				createDatabaseRegistrationOptionsModel.DatabaseType = core.StringPtr("db2")
				createDatabaseRegistrationOptionsModel.AssociatedCatalog = databaseCatalogModel
				createDatabaseRegistrationOptionsModel.CreatedOn = core.StringPtr("1686792721")
				createDatabaseRegistrationOptionsModel.DatabaseDetails = databaseDetailsModel
				createDatabaseRegistrationOptionsModel.DatabaseProperties = []watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}
				createDatabaseRegistrationOptionsModel.Description = core.StringPtr("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.Tags = []string{"testdatabase", "userdatabase"}
				createDatabaseRegistrationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDatabaseRegistrationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateDatabaseRegistration(createDatabaseRegistrationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetDatabase(getDatabaseOptions *GetDatabaseOptions) - Operation response error`, func() {
		getDatabasePath := "/database_registrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getDatabasePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetDatabase with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetDatabase(getDatabaseOptions *GetDatabaseOptions)`, func() {
		getDatabasePath := "/database_registrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getDatabasePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "database_name": "new_database", "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "password": "samplepassword", "port": 4553, "sasl": true, "ssl": true, "tables": "kafka_table_name", "username": "sampleuser", "validate_server_certificate": true}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "description": "Description of the external Database", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke GetDatabase successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetDatabaseWithContext(ctx, getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetDatabaseWithContext(ctx, getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getDatabasePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "database_name": "new_database", "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "password": "samplepassword", "port": 4553, "sasl": true, "ssl": true, "tables": "kafka_table_name", "username": "sampleuser", "validate_server_certificate": true}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "description": "Description of the external Database", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke GetDatabase successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetDatabase(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetDatabase with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetDatabaseOptions model with no property values
				getDatabaseOptionsModelNew := new(watsonxdatav2.GetDatabaseOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetDatabase(getDatabaseOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetDatabase successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetDatabaseOptions model
				getDatabaseOptionsModel := new(watsonxdatav2.GetDatabaseOptions)
				getDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				getDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetDatabase(getDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteDatabaseCatalog(deleteDatabaseCatalogOptions *DeleteDatabaseCatalogOptions)`, func() {
		deleteDatabaseCatalogPath := "/database_registrations/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteDatabaseCatalogPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteDatabaseCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteDatabaseCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteDatabaseCatalogOptions model
				deleteDatabaseCatalogOptionsModel := new(watsonxdatav2.DeleteDatabaseCatalogOptions)
				deleteDatabaseCatalogOptionsModel.DatabaseID = core.StringPtr("testString")
				deleteDatabaseCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDatabaseCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteDatabaseCatalog(deleteDatabaseCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteDatabaseCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteDatabaseCatalogOptions model
				deleteDatabaseCatalogOptionsModel := new(watsonxdatav2.DeleteDatabaseCatalogOptions)
				deleteDatabaseCatalogOptionsModel.DatabaseID = core.StringPtr("testString")
				deleteDatabaseCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDatabaseCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteDatabaseCatalog(deleteDatabaseCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteDatabaseCatalogOptions model with no property values
				deleteDatabaseCatalogOptionsModelNew := new(watsonxdatav2.DeleteDatabaseCatalogOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteDatabaseCatalog(deleteDatabaseCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateDatabase(updateDatabaseOptions *UpdateDatabaseOptions) - Operation response error`, func() {
		updateDatabasePath := "/database_registrations/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDatabasePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateDatabase with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateDatabase(updateDatabaseOptions *UpdateDatabaseOptions)`, func() {
		updateDatabasePath := "/database_registrations/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDatabasePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "database_name": "new_database", "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "password": "samplepassword", "port": 4553, "sasl": true, "ssl": true, "tables": "kafka_table_name", "username": "sampleuser", "validate_server_certificate": true}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "description": "Description of the external Database", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke UpdateDatabase successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateDatabaseWithContext(ctx, updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateDatabaseWithContext(ctx, updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDatabasePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalog": {"catalog_name": "sampleCatalog", "catalog_tags": ["CatalogTags"], "catalog_type": "iceberg"}, "catalog_name": "sampleCatalog", "created_by": "user1@bim.com", "created_on": "1686792721", "database_details": {"certificate": "contents of a pem/crt file", "certificate_extension": "pem/crt", "database_name": "new_database", "hostname": "db2@<hostname>.com", "hostname_in_certificate": "samplehostname", "hosts": "abc.com:1234,xyz.com:4321", "password": "samplepassword", "port": 4553, "sasl": true, "ssl": true, "tables": "kafka_table_name", "username": "sampleuser", "validate_server_certificate": true}, "database_display_name": "new_database", "database_id": "new_database_id", "database_properties": [{"encrypt": true, "key": "hive.metastore", "value": "glue"}], "database_type": "netezza", "description": "Description of the external Database", "tags": ["Tags"]}`)
				}))
			})
			It(`Invoke UpdateDatabase successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateDatabase(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateDatabase with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateDatabaseOptions model with no property values
				updateDatabaseOptionsModelNew := new(watsonxdatav2.UpdateDatabaseOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateDatabase(updateDatabaseOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateDatabase successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DatabaseRegistrationPatchDatabaseDetails model
				databaseRegistrationPatchDatabaseDetailsModel := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
				databaseRegistrationPatchDatabaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseRegistrationPatchDatabaseDetailsModel.Username = core.StringPtr("sampleuser")

				// Construct an instance of the DatabaseRegistrationPatch model
				databaseRegistrationPatchModel := new(watsonxdatav2.DatabaseRegistrationPatch)
				databaseRegistrationPatchModel.DatabaseDetails = databaseRegistrationPatchDatabaseDetailsModel
				databaseRegistrationPatchModel.DatabaseDisplayName = core.StringPtr("new_database")
				databaseRegistrationPatchModel.Description = core.StringPtr("External database description")
				databaseRegistrationPatchModel.Tags = []string{"testdatabase", "userdatabase"}
				databaseRegistrationPatchModelAsPatch, asPatchErr := databaseRegistrationPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDatabaseOptions model
				updateDatabaseOptionsModel := new(watsonxdatav2.UpdateDatabaseOptions)
				updateDatabaseOptionsModel.DatabaseID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Body = databaseRegistrationPatchModelAsPatch
				updateDatabaseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDatabaseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateDatabase(updateDatabaseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOtherEngines(listOtherEnginesOptions *ListOtherEnginesOptions) - Operation response error`, func() {
		listOtherEnginesPath := "/other_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOtherEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListOtherEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListOtherEngines(listOtherEnginesOptions *ListOtherEnginesOptions)`, func() {
		listOtherEnginesPath := "/other_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOtherEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"other_engines": [{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "engine_type": "netezza", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "registered", "tags": ["Tags"], "type": "external"}]}`)
				}))
			})
			It(`Invoke ListOtherEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListOtherEnginesWithContext(ctx, listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListOtherEnginesWithContext(ctx, listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listOtherEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"other_engines": [{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "engine_type": "netezza", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "registered", "tags": ["Tags"], "type": "external"}]}`)
				}))
			})
			It(`Invoke ListOtherEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListOtherEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListOtherEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListOtherEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := new(watsonxdatav2.ListOtherEnginesOptions)
				listOtherEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listOtherEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListOtherEngines(listOtherEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOtherEngine(createOtherEngineOptions *CreateOtherEngineOptions) - Operation response error`, func() {
		createOtherEnginePath := "/other_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOtherEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateOtherEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.Type = core.StringPtr("netezza")
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateOtherEngine(createOtherEngineOptions *CreateOtherEngineOptions)`, func() {
		createOtherEnginePath := "/other_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOtherEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "engine_type": "netezza", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "registered", "tags": ["Tags"], "type": "external"}`)
				}))
			})
			It(`Invoke CreateOtherEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.Type = core.StringPtr("netezza")
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateOtherEngineWithContext(ctx, createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateOtherEngineWithContext(ctx, createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createOtherEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "engine_type": "netezza", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "registered", "tags": ["Tags"], "type": "external"}`)
				}))
			})
			It(`Invoke CreateOtherEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateOtherEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.Type = core.StringPtr("netezza")
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateOtherEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.Type = core.StringPtr("netezza")
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateOtherEngineOptions model with no property values
				createOtherEngineOptionsModelNew := new(watsonxdatav2.CreateOtherEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateOtherEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")

				// Construct an instance of the CreateOtherEngineOptions model
				createOtherEngineOptionsModel := new(watsonxdatav2.CreateOtherEngineOptions)
				createOtherEngineOptionsModel.EngineDetails = otherEngineDetailsBodyModel
				createOtherEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine01")
				createOtherEngineOptionsModel.Description = core.StringPtr("external engine description")
				createOtherEngineOptionsModel.Origin = core.StringPtr("external")
				createOtherEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createOtherEngineOptionsModel.Type = core.StringPtr("netezza")
				createOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateOtherEngine(createOtherEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteOtherEngine(deleteOtherEngineOptions *DeleteOtherEngineOptions)`, func() {
		deleteOtherEnginePath := "/other_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteOtherEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteOtherEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteOtherEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteOtherEngineOptions model
				deleteOtherEngineOptionsModel := new(watsonxdatav2.DeleteOtherEngineOptions)
				deleteOtherEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteOtherEngine(deleteOtherEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteOtherEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteOtherEngineOptions model
				deleteOtherEngineOptionsModel := new(watsonxdatav2.DeleteOtherEngineOptions)
				deleteOtherEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteOtherEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteOtherEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteOtherEngine(deleteOtherEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteOtherEngineOptions model with no property values
				deleteOtherEngineOptionsModelNew := new(watsonxdatav2.DeleteOtherEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteOtherEngine(deleteOtherEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListDb2Engines(listDb2EnginesOptions *ListDb2EnginesOptions) - Operation response error`, func() {
		listDb2EnginesPath := "/db2_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDb2EnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListDb2Engines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListDb2Engines(listDb2EnginesOptions *ListDb2EnginesOptions)`, func() {
		listDb2EnginesPath := "/db2_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDb2EnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"db2_engines": [{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}]}`)
				}))
			})
			It(`Invoke ListDb2Engines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListDb2EnginesWithContext(ctx, listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListDb2EnginesWithContext(ctx, listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listDb2EnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"db2_engines": [{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}]}`)
				}))
			})
			It(`Invoke ListDb2Engines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListDb2Engines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListDb2Engines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListDb2Engines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := new(watsonxdatav2.ListDb2EnginesOptions)
				listDb2EnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listDb2EnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListDb2Engines(listDb2EnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateDb2Engine(createDb2EngineOptions *CreateDb2EngineOptions) - Operation response error`, func() {
		createDb2EnginePath := "/db2_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDb2EnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateDb2Engine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateDb2Engine(createDb2EngineOptions *CreateDb2EngineOptions)`, func() {
		createDb2EnginePath := "/db2_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDb2EnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}`)
				}))
			})
			It(`Invoke CreateDb2Engine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateDb2EngineWithContext(ctx, createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateDb2EngineWithContext(ctx, createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createDb2EnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}`)
				}))
			})
			It(`Invoke CreateDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateDb2Engine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateDb2Engine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateDb2EngineOptions model with no property values
				createDb2EngineOptionsModelNew := new(watsonxdatav2.CreateDb2EngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsModel := new(watsonxdatav2.CreateDb2EngineOptions)
				createDb2EngineOptionsModel.Origin = core.StringPtr("external")
				createDb2EngineOptionsModel.Description = core.StringPtr("db2 engine description")
				createDb2EngineOptionsModel.EngineDetails = db2EngineDetailsBodyModel
				createDb2EngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createDb2EngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateDb2Engine(createDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteDb2Engine(deleteDb2EngineOptions *DeleteDb2EngineOptions)`, func() {
		deleteDb2EnginePath := "/db2_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteDb2EnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteDb2Engine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteDb2EngineOptions model
				deleteDb2EngineOptionsModel := new(watsonxdatav2.DeleteDb2EngineOptions)
				deleteDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteDb2Engine(deleteDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteDb2Engine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteDb2EngineOptions model
				deleteDb2EngineOptionsModel := new(watsonxdatav2.DeleteDb2EngineOptions)
				deleteDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteDb2Engine(deleteDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteDb2EngineOptions model with no property values
				deleteDb2EngineOptionsModelNew := new(watsonxdatav2.DeleteDb2EngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteDb2Engine(deleteDb2EngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateDb2Engine(updateDb2EngineOptions *UpdateDb2EngineOptions) - Operation response error`, func() {
		updateDb2EnginePath := "/db2_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDb2EnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateDb2Engine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateDb2Engine(updateDb2EngineOptions *UpdateDb2EngineOptions)`, func() {
		updateDb2EnginePath := "/db2_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDb2EnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}`)
				}))
			})
			It(`Invoke UpdateDb2Engine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateDb2EngineWithContext(ctx, updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateDb2EngineWithContext(ctx, updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateDb2EnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "db2 engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-db2-01-db2-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "db2"}`)
				}))
			})
			It(`Invoke UpdateDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateDb2Engine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateDb2EngineOptions model with no property values
				updateDb2EngineOptionsModelNew := new(watsonxdatav2.UpdateDb2EngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateDb2Engine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Db2EnginePatch model
				db2EnginePatchModel := new(watsonxdatav2.Db2EnginePatch)
				db2EnginePatchModel.Description = core.StringPtr("db2 engine updated description")
				db2EnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				db2EnginePatchModel.Tags = []string{"tag1", "tag2"}
				db2EnginePatchModelAsPatch, asPatchErr := db2EnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateDb2EngineOptions model
				updateDb2EngineOptionsModel := new(watsonxdatav2.UpdateDb2EngineOptions)
				updateDb2EngineOptionsModel.EngineID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Body = db2EnginePatchModelAsPatch
				updateDb2EngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateDb2EngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateDb2Engine(updateDb2EngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListNetezzaEngines(listNetezzaEnginesOptions *ListNetezzaEnginesOptions) - Operation response error`, func() {
		listNetezzaEnginesPath := "/netezza_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listNetezzaEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListNetezzaEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListNetezzaEngines(listNetezzaEnginesOptions *ListNetezzaEnginesOptions)`, func() {
		listNetezzaEnginesPath := "/netezza_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listNetezzaEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"netezza_engines": [{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}]}`)
				}))
			})
			It(`Invoke ListNetezzaEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListNetezzaEnginesWithContext(ctx, listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListNetezzaEnginesWithContext(ctx, listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listNetezzaEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"netezza_engines": [{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}]}`)
				}))
			})
			It(`Invoke ListNetezzaEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListNetezzaEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListNetezzaEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := new(watsonxdatav2.ListNetezzaEnginesOptions)
				listNetezzaEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listNetezzaEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListNetezzaEngines(listNetezzaEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateNetezzaEngine(createNetezzaEngineOptions *CreateNetezzaEngineOptions) - Operation response error`, func() {
		createNetezzaEnginePath := "/netezza_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createNetezzaEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateNetezzaEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateNetezzaEngine(createNetezzaEngineOptions *CreateNetezzaEngineOptions)`, func() {
		createNetezzaEnginePath := "/netezza_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createNetezzaEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}`)
				}))
			})
			It(`Invoke CreateNetezzaEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateNetezzaEngineWithContext(ctx, createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateNetezzaEngineWithContext(ctx, createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createNetezzaEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}`)
				}))
			})
			It(`Invoke CreateNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateNetezzaEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateNetezzaEngineOptions model with no property values
				createNetezzaEngineOptionsModelNew := new(watsonxdatav2.CreateNetezzaEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsModel := new(watsonxdatav2.CreateNetezzaEngineOptions)
				createNetezzaEngineOptionsModel.Origin = core.StringPtr("external")
				createNetezzaEngineOptionsModel.Description = core.StringPtr("netezza engine description")
				createNetezzaEngineOptionsModel.EngineDetails = netezzaEngineDetailsBodyModel
				createNetezzaEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createNetezzaEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateNetezzaEngine(createNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteNetezzaEngine(deleteNetezzaEngineOptions *DeleteNetezzaEngineOptions)`, func() {
		deleteNetezzaEnginePath := "/netezza_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteNetezzaEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteNetezzaEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteNetezzaEngineOptions model
				deleteNetezzaEngineOptionsModel := new(watsonxdatav2.DeleteNetezzaEngineOptions)
				deleteNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteNetezzaEngine(deleteNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteNetezzaEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteNetezzaEngineOptions model
				deleteNetezzaEngineOptionsModel := new(watsonxdatav2.DeleteNetezzaEngineOptions)
				deleteNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteNetezzaEngine(deleteNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteNetezzaEngineOptions model with no property values
				deleteNetezzaEngineOptionsModelNew := new(watsonxdatav2.DeleteNetezzaEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteNetezzaEngine(deleteNetezzaEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateNetezzaEngine(updateNetezzaEngineOptions *UpdateNetezzaEngineOptions) - Operation response error`, func() {
		updateNetezzaEnginePath := "/netezza_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateNetezzaEnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateNetezzaEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateNetezzaEngine(updateNetezzaEngineOptions *UpdateNetezzaEngineOptions)`, func() {
		updateNetezzaEnginePath := "/netezza_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateNetezzaEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}`)
				}))
			})
			It(`Invoke UpdateNetezzaEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateNetezzaEngineWithContext(ctx, updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateNetezzaEngineWithContext(ctx, updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateNetezzaEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "netezza engine for running sql queries", "engine_details": {"connection_string": "1.2.3.4", "metastore_host": "1.2.3.4"}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "host_name": "xyz-netezza-01-netezza-svc", "origin": "ibm", "port": 4, "status": "REGISTERED", "tags": ["Tags"], "type": "netezza"}`)
				}))
			})
			It(`Invoke UpdateNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateNetezzaEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateNetezzaEngineOptions model with no property values
				updateNetezzaEngineOptionsModelNew := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateNetezzaEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NetezzaEnginePatch model
				netezzaEnginePatchModel := new(watsonxdatav2.NetezzaEnginePatch)
				netezzaEnginePatchModel.Description = core.StringPtr("netezza engine updated description")
				netezzaEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				netezzaEnginePatchModel.Tags = []string{"tag1", "tag2"}
				netezzaEnginePatchModelAsPatch, asPatchErr := netezzaEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateNetezzaEngineOptions model
				updateNetezzaEngineOptionsModel := new(watsonxdatav2.UpdateNetezzaEngineOptions)
				updateNetezzaEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Body = netezzaEnginePatchModelAsPatch
				updateNetezzaEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateNetezzaEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateNetezzaEngine(updateNetezzaEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestissimoEngines(listPrestissimoEnginesOptions *ListPrestissimoEnginesOptions) - Operation response error`, func() {
		listPrestissimoEnginesPath := "/prestissimo_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListPrestissimoEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestissimoEngines(listPrestissimoEnginesOptions *ListPrestissimoEnginesOptions)`, func() {
		listPrestissimoEnginesPath := "/prestissimo_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"prestissimo_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}]}`)
				}))
			})
			It(`Invoke ListPrestissimoEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListPrestissimoEnginesWithContext(ctx, listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListPrestissimoEnginesWithContext(ctx, listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"prestissimo_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}]}`)
				}))
			})
			It(`Invoke ListPrestissimoEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListPrestissimoEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListPrestissimoEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := new(watsonxdatav2.ListPrestissimoEnginesOptions)
				listPrestissimoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListPrestissimoEngines(listPrestissimoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestissimoEngine(createPrestissimoEngineOptions *CreatePrestissimoEngineOptions) - Operation response error`, func() {
		createPrestissimoEnginePath := "/prestissimo_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreatePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestissimoEngine(createPrestissimoEngineOptions *CreatePrestissimoEngineOptions)`, func() {
		createPrestissimoEnginePath := "/prestissimo_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke CreatePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreatePrestissimoEngineWithContext(ctx, createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreatePrestissimoEngineWithContext(ctx, createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke CreatePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreatePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreatePrestissimoEngineOptions model with no property values
				createPrestissimoEngineOptionsModelNew := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreatePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsModel := new(watsonxdatav2.CreatePrestissimoEngineOptions)
				createPrestissimoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestissimoEngineOptionsModel.AssociatedCatalogs = []string{"hive_data"}
				createPrestissimoEngineOptionsModel.Description = core.StringPtr("prestissimo engine description")
				createPrestissimoEngineOptionsModel.EngineDetails = prestissimoEngineDetailsModel
				createPrestissimoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestissimoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestissimoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestissimoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreatePrestissimoEngine(createPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestissimoEngine(getPrestissimoEngineOptions *GetPrestissimoEngineOptions) - Operation response error`, func() {
		getPrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEnginePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestissimoEngine(getPrestissimoEngineOptions *GetPrestissimoEngineOptions)`, func() {
		getPrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke GetPrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetPrestissimoEngineWithContext(ctx, getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetPrestissimoEngineWithContext(ctx, getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke GetPrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPrestissimoEngineOptions model with no property values
				getPrestissimoEngineOptionsModelNew := new(watsonxdatav2.GetPrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineOptions model
				getPrestissimoEngineOptionsModel := new(watsonxdatav2.GetPrestissimoEngineOptions)
				getPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetPrestissimoEngine(getPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeletePrestissimoEngine(deletePrestissimoEngineOptions *DeletePrestissimoEngineOptions)`, func() {
		deletePrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deletePrestissimoEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeletePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeletePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeletePrestissimoEngineOptions model
				deletePrestissimoEngineOptionsModel := new(watsonxdatav2.DeletePrestissimoEngineOptions)
				deletePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeletePrestissimoEngine(deletePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeletePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeletePrestissimoEngineOptions model
				deletePrestissimoEngineOptionsModel := new(watsonxdatav2.DeletePrestissimoEngineOptions)
				deletePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeletePrestissimoEngine(deletePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeletePrestissimoEngineOptions model with no property values
				deletePrestissimoEngineOptionsModelNew := new(watsonxdatav2.DeletePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeletePrestissimoEngine(deletePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdatePrestissimoEngine(updatePrestissimoEngineOptions *UpdatePrestissimoEngineOptions) - Operation response error`, func() {
		updatePrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestissimoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdatePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdatePrestissimoEngine(updatePrestissimoEngineOptions *UpdatePrestissimoEngineOptions)`, func() {
		updatePrestissimoEnginePath := "/prestissimo_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestissimoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke UpdatePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdatePrestissimoEngineWithContext(ctx, updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdatePrestissimoEngineWithContext(ctx, updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestissimoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "prestissimo engine for running sql queries", "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications"}, "instance_id": "instance_id", "managed_by": "fully/self", "metastore_host": "1.2.3.4", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "velox": {"velox_property": ["VeloxProperty"]}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "xyz-prestissimo-01-prestissimo-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"catalog": {"catalog_name": ["CatalogName"]}, "configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "velox": ["Velox"]}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "prestissimo", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke UpdatePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdatePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdatePrestissimoEngineOptions model with no property values
				updatePrestissimoEngineOptionsModelNew := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdatePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoEnginePropertiesCatalog model
				prestissimoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
				prestissimoEnginePropertiesCatalogModel.CatalogName = []string{"testString"}

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGenConfiguration model
				enginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
				enginePropertiesOaiGenConfigurationModel.Coordinator = prestissimoNodeDescriptionBodyModel
				enginePropertiesOaiGenConfigurationModel.Worker = prestissimoNodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEnginePropertiesVelox model
				prestissimoEnginePropertiesVeloxModel := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
				prestissimoEnginePropertiesVeloxModel.VeloxProperty = []string{"testString"}

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the PrestissimoEnginePropertiesOaiGen1Jvm model
				prestissimoEnginePropertiesOaiGen1JvmModel := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
				prestissimoEnginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel

				// Construct an instance of the PrestissimoEngineEngineProperties model
				prestissimoEngineEnginePropertiesModel := new(watsonxdatav2.PrestissimoEngineEngineProperties)
				prestissimoEngineEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				prestissimoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGenConfigurationModel
				prestissimoEngineEnginePropertiesModel.Velox = prestissimoEnginePropertiesVeloxModel
				prestissimoEngineEnginePropertiesModel.Jvm = prestissimoEnginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesConfiguration model
				removeEnginePropertiesConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
				removeEnginePropertiesConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEngineProperties model
				removeEnginePropertiesModel := new(watsonxdatav2.RemoveEngineProperties)
				removeEnginePropertiesModel.Catalog = prestissimoEnginePropertiesCatalogModel
				removeEnginePropertiesModel.Configuration = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Jvm = removeEnginePropertiesConfigurationModel
				removeEnginePropertiesModel.Velox = []string{"testString"}

				// Construct an instance of the PrestissimoEnginePatch model
				prestissimoEnginePatchModel := new(watsonxdatav2.PrestissimoEnginePatch)
				prestissimoEnginePatchModel.Description = core.StringPtr("updated description for prestissimo engine")
				prestissimoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestissimoEnginePatchModel.EngineProperties = prestissimoEngineEnginePropertiesModel
				prestissimoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestissimoEnginePatchModel.RemoveEngineProperties = removeEnginePropertiesModel
				prestissimoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestissimoEnginePatchModelAsPatch, asPatchErr := prestissimoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestissimoEngineOptions model
				updatePrestissimoEngineOptionsModel := new(watsonxdatav2.UpdatePrestissimoEngineOptions)
				updatePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Body = prestissimoEnginePatchModelAsPatch
				updatePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdatePrestissimoEngine(updatePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptions *ListPrestissimoEngineCatalogsOptions) - Operation response error`, func() {
		listPrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListPrestissimoEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptions *ListPrestissimoEngineCatalogsOptions)`, func() {
		listPrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListPrestissimoEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListPrestissimoEngineCatalogsWithContext(ctx, listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListPrestissimoEngineCatalogsWithContext(ctx, listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListPrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListPrestissimoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListPrestissimoEngineCatalogsOptions model with no property values
				listPrestissimoEngineCatalogsOptionsModelNew := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListPrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				listPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestissimoEngineCatalogsOptions)
				listPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListPrestissimoEngineCatalogs(listPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddPrestissimoEngineCatalogs(addPrestissimoEngineCatalogsOptions *AddPrestissimoEngineCatalogsOptions) - Operation response error`, func() {
		addPrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke AddPrestissimoEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the AddPrestissimoEngineCatalogsOptions model
				addPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestissimoEngineCatalogsOptions)
				addPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.AddPrestissimoEngineCatalogs(addPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.AddPrestissimoEngineCatalogs(addPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddPrestissimoEngineCatalogs(addPrestissimoEngineCatalogsOptions *AddPrestissimoEngineCatalogsOptions)`, func() {
		addPrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke AddPrestissimoEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the AddPrestissimoEngineCatalogsOptions model
				addPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestissimoEngineCatalogsOptions)
				addPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.AddPrestissimoEngineCatalogsWithContext(ctx, addPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.AddPrestissimoEngineCatalogs(addPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.AddPrestissimoEngineCatalogsWithContext(ctx, addPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addPrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke AddPrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.AddPrestissimoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the AddPrestissimoEngineCatalogsOptions model
				addPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestissimoEngineCatalogsOptions)
				addPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.AddPrestissimoEngineCatalogs(addPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke AddPrestissimoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the AddPrestissimoEngineCatalogsOptions model
				addPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestissimoEngineCatalogsOptions)
				addPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.AddPrestissimoEngineCatalogs(addPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the AddPrestissimoEngineCatalogsOptions model with no property values
				addPrestissimoEngineCatalogsOptionsModelNew := new(watsonxdatav2.AddPrestissimoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.AddPrestissimoEngineCatalogs(addPrestissimoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke AddPrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the AddPrestissimoEngineCatalogsOptions model
				addPrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestissimoEngineCatalogsOptions)
				addPrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.AddPrestissimoEngineCatalogs(addPrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeletePrestissimoEngineCatalogs(deletePrestissimoEngineCatalogsOptions *DeletePrestissimoEngineCatalogsOptions)`, func() {
		deletePrestissimoEngineCatalogsPath := "/prestissimo_engines/testString/catalogs"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deletePrestissimoEngineCatalogsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_names"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeletePrestissimoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeletePrestissimoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeletePrestissimoEngineCatalogsOptions model
				deletePrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.DeletePrestissimoEngineCatalogsOptions)
				deletePrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeletePrestissimoEngineCatalogs(deletePrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeletePrestissimoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeletePrestissimoEngineCatalogsOptions model
				deletePrestissimoEngineCatalogsOptionsModel := new(watsonxdatav2.DeletePrestissimoEngineCatalogsOptions)
				deletePrestissimoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestissimoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeletePrestissimoEngineCatalogs(deletePrestissimoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeletePrestissimoEngineCatalogsOptions model with no property values
				deletePrestissimoEngineCatalogsOptionsModelNew := new(watsonxdatav2.DeletePrestissimoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeletePrestissimoEngineCatalogs(deletePrestissimoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptions *GetPrestissimoEngineCatalogOptions) - Operation response error`, func() {
		getPrestissimoEngineCatalogPath := "/prestissimo_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPrestissimoEngineCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptions *GetPrestissimoEngineCatalogOptions)`, func() {
		getPrestissimoEngineCatalogPath := "/prestissimo_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetPrestissimoEngineCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetPrestissimoEngineCatalogWithContext(ctx, getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetPrestissimoEngineCatalogWithContext(ctx, getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestissimoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetPrestissimoEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPrestissimoEngineCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPrestissimoEngineCatalogOptions model with no property values
				getPrestissimoEngineCatalogOptionsModelNew := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPrestissimoEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				getPrestissimoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestissimoEngineCatalogOptions)
				getPrestissimoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestissimoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetPrestissimoEngineCatalog(getPrestissimoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PausePrestissimoEngine(pausePrestissimoEngineOptions *PausePrestissimoEngineOptions) - Operation response error`, func() {
		pausePrestissimoEnginePath := "/prestissimo_engines/testString/pause"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke PausePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PausePrestissimoEngine(pausePrestissimoEngineOptions *PausePrestissimoEngineOptions)`, func() {
		pausePrestissimoEnginePath := "/prestissimo_engines/testString/pause"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke PausePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.PausePrestissimoEngineWithContext(ctx, pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.PausePrestissimoEngineWithContext(ctx, pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke PausePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke PausePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the PausePrestissimoEngineOptions model with no property values
				pausePrestissimoEngineOptionsModelNew := new(watsonxdatav2.PausePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke PausePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestissimoEngineOptions model
				pausePrestissimoEngineOptionsModel := new(watsonxdatav2.PausePrestissimoEngineOptions)
				pausePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.PausePrestissimoEngine(pausePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptions *RunPrestissimoExplainStatementOptions) - Operation response error`, func() {
		runPrestissimoExplainStatementPath := "/prestissimo_engines/testString/query_explain"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RunPrestissimoExplainStatement with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptions *RunPrestissimoExplainStatementOptions)`, func() {
		runPrestissimoExplainStatementPath := "/prestissimo_engines/testString/query_explain"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"result": "Result"}`)
				}))
			})
			It(`Invoke RunPrestissimoExplainStatement successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RunPrestissimoExplainStatementWithContext(ctx, runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RunPrestissimoExplainStatementWithContext(ctx, runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"result": "Result"}`)
				}))
			})
			It(`Invoke RunPrestissimoExplainStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RunPrestissimoExplainStatement with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RunPrestissimoExplainStatementOptions model with no property values
				runPrestissimoExplainStatementOptionsModelNew := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RunPrestissimoExplainStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				runPrestissimoExplainStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainStatementOptions)
				runPrestissimoExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.Format = core.StringPtr("json")
				runPrestissimoExplainStatementOptionsModel.Type = core.StringPtr("io")
				runPrestissimoExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainStatement(runPrestissimoExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptions *RunPrestissimoExplainAnalyzeStatementOptions) - Operation response error`, func() {
		runPrestissimoExplainAnalyzeStatementPath := "/prestissimo_engines/testString/query_explain_analyze"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptions *RunPrestissimoExplainAnalyzeStatementOptions)`, func() {
		runPrestissimoExplainAnalyzeStatementPath := "/prestissimo_engines/testString/query_explain_analyze"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"result": "Result"}`)
				}))
			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatementWithContext(ctx, runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RunPrestissimoExplainAnalyzeStatementWithContext(ctx, runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runPrestissimoExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"result": "Result"}`)
				}))
			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RunPrestissimoExplainAnalyzeStatementOptions model with no property values
				runPrestissimoExplainAnalyzeStatementOptionsModelNew := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RunPrestissimoExplainAnalyzeStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				runPrestissimoExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunPrestissimoExplainAnalyzeStatementOptions)
				runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RunPrestissimoExplainAnalyzeStatement(runPrestissimoExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RestartPrestissimoEngine(restartPrestissimoEngineOptions *RestartPrestissimoEngineOptions) - Operation response error`, func() {
		restartPrestissimoEnginePath := "/prestissimo_engines/testString/restart"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RestartPrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RestartPrestissimoEngine(restartPrestissimoEngineOptions *RestartPrestissimoEngineOptions)`, func() {
		restartPrestissimoEnginePath := "/prestissimo_engines/testString/restart"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke RestartPrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RestartPrestissimoEngineWithContext(ctx, restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RestartPrestissimoEngineWithContext(ctx, restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke RestartPrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RestartPrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RestartPrestissimoEngineOptions model with no property values
				restartPrestissimoEngineOptionsModelNew := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RestartPrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestissimoEngineOptions model
				restartPrestissimoEngineOptionsModel := new(watsonxdatav2.RestartPrestissimoEngineOptions)
				restartPrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RestartPrestissimoEngine(restartPrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumePrestissimoEngine(resumePrestissimoEngineOptions *ResumePrestissimoEngineOptions) - Operation response error`, func() {
		resumePrestissimoEnginePath := "/prestissimo_engines/testString/resume"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ResumePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumePrestissimoEngine(resumePrestissimoEngineOptions *ResumePrestissimoEngineOptions)`, func() {
		resumePrestissimoEnginePath := "/prestissimo_engines/testString/resume"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ResumePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ResumePrestissimoEngineWithContext(ctx, resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ResumePrestissimoEngineWithContext(ctx, resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ResumePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ResumePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ResumePrestissimoEngineOptions model with no property values
				resumePrestissimoEngineOptionsModelNew := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ResumePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestissimoEngineOptions model
				resumePrestissimoEngineOptionsModel := new(watsonxdatav2.ResumePrestissimoEngineOptions)
				resumePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ResumePrestissimoEngine(resumePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScalePrestissimoEngine(scalePrestissimoEngineOptions *ScalePrestissimoEngineOptions) - Operation response error`, func() {
		scalePrestissimoEnginePath := "/prestissimo_engines/testString/scale"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ScalePrestissimoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScalePrestissimoEngine(scalePrestissimoEngineOptions *ScalePrestissimoEngineOptions)`, func() {
		scalePrestissimoEnginePath := "/prestissimo_engines/testString/scale"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ScalePrestissimoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ScalePrestissimoEngineWithContext(ctx, scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ScalePrestissimoEngineWithContext(ctx, scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestissimoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke ScalePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ScalePrestissimoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ScalePrestissimoEngineOptions model with no property values
				scalePrestissimoEngineOptionsModelNew := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke ScalePrestissimoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				scalePrestissimoEngineOptionsModel := new(watsonxdatav2.ScalePrestissimoEngineOptions)
				scalePrestissimoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.Worker = prestissimoNodeDescriptionBodyModel
				scalePrestissimoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestissimoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ScalePrestissimoEngine(scalePrestissimoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestoEngines(listPrestoEnginesOptions *ListPrestoEnginesOptions) - Operation response error`, func() {
		listPrestoEnginesPath := "/presto_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListPrestoEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestoEngines(listPrestoEnginesOptions *ListPrestoEnginesOptions)`, func() {
		listPrestoEnginesPath := "/presto_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"presto_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "catalog": {"catalog_name": "CatalogName"}}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}]}`)
				}))
			})
			It(`Invoke ListPrestoEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListPrestoEnginesWithContext(ctx, listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListPrestoEnginesWithContext(ctx, listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"presto_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "catalog": {"catalog_name": "CatalogName"}}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}]}`)
				}))
			})
			It(`Invoke ListPrestoEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListPrestoEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListPrestoEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListPrestoEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := new(watsonxdatav2.ListPrestoEnginesOptions)
				listPrestoEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListPrestoEngines(listPrestoEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestoEngine(createPrestoEngineOptions *CreatePrestoEngineOptions) - Operation response error`, func() {
		createPrestoEnginePath := "/presto_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreatePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePrestoEngine(createPrestoEngineOptions *CreatePrestoEngineOptions)`, func() {
		createPrestoEnginePath := "/presto_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "catalog": {"catalog_name": "CatalogName"}}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke CreatePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreatePrestoEngineWithContext(ctx, createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreatePrestoEngineWithContext(ctx, createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "catalog": {"catalog_name": "CatalogName"}}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke CreatePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreatePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreatePrestoEngineOptions model with no property values
				createPrestoEngineOptionsModelNew := new(watsonxdatav2.CreatePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreatePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsModel := new(watsonxdatav2.CreatePrestoEngineOptions)
				createPrestoEngineOptionsModel.Origin = core.StringPtr("native")
				createPrestoEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data", "hive_data"}
				createPrestoEngineOptionsModel.Description = core.StringPtr("presto engine for running sql queries")
				createPrestoEngineOptionsModel.EngineDetails = engineDetailsBodyModel
				createPrestoEngineOptionsModel.EngineDisplayName = core.StringPtr("sampleEngine")
				createPrestoEngineOptionsModel.Region = core.StringPtr("us-south")
				createPrestoEngineOptionsModel.Tags = []string{"tag1", "tag2"}
				createPrestoEngineOptionsModel.Version = core.StringPtr("1.2.3")
				createPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreatePrestoEngine(createPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestoEngine(getPrestoEngineOptions *GetPrestoEngineOptions) - Operation response error`, func() {
		getPrestoEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEnginePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestoEngine(getPrestoEngineOptions *GetPrestoEngineOptions)`, func() {
		getPrestoEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "catalog": {"catalog_name": "CatalogName"}}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke GetPrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetPrestoEngineWithContext(ctx, getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetPrestoEngineWithContext(ctx, getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "catalog": {"catalog_name": "CatalogName"}}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke GetPrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetPrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPrestoEngineOptions model with no property values
				getPrestoEngineOptionsModelNew := new(watsonxdatav2.GetPrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineOptions model
				getPrestoEngineOptionsModel := new(watsonxdatav2.GetPrestoEngineOptions)
				getPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetPrestoEngine(getPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteEngine(deleteEngineOptions *DeleteEngineOptions)`, func() {
		deleteEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteEngineOptions model
				deleteEngineOptionsModel := new(watsonxdatav2.DeleteEngineOptions)
				deleteEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteEngine(deleteEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteEngineOptions model
				deleteEngineOptionsModel := new(watsonxdatav2.DeleteEngineOptions)
				deleteEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteEngine(deleteEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteEngineOptions model with no property values
				deleteEngineOptionsModelNew := new(watsonxdatav2.DeleteEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteEngine(deleteEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdatePrestoEngine(updatePrestoEngineOptions *UpdatePrestoEngineOptions) - Operation response error`, func() {
		updatePrestoEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdatePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdatePrestoEngine(updatePrestoEngineOptions *UpdatePrestoEngineOptions)`, func() {
		updatePrestoEnginePath := "/presto_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "catalog": {"catalog_name": "CatalogName"}}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke UpdatePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdatePrestoEngineWithContext(ctx, updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdatePrestoEngineWithContext(ctx, updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updatePrestoEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "coordinator": {"node_type": "worker", "quantity": 8}, "created_by": "<username>@<domain>.com", "created_on": 9, "description": "presto engine for running sql queries", "drivers": [{"connection_type": "saphana", "driver_id": "saphanadriver123", "driver_name": "saphanadriver-1.2.3", "driver_version": "1.2.3"}], "engine_details": {"api_key": "<api_key>", "connection_string": "1.2.3.4", "coordinator": {"node_type": "worker", "quantity": 8}, "instance_id": "instance_id", "managed_by": "fully/self", "size_config": "starter", "worker": {"node_type": "worker", "quantity": 8}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "engine_properties": {"catalog": {"catalog_name": "CatalogName"}, "configuration": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}, "global": {"global_property": "enable-mixed-case-support:true"}, "jvm": {"coordinator": {"node_type": "worker", "quantity": 8}, "worker": {"node_type": "worker", "quantity": 8}}}, "engine_restart": "force", "external_host_name": "your-hostname.apps.your-domain.com", "group_id": "new_group_id", "host_name": "ibm-lh-lakehouse-presto-01-presto-svc", "origin": "native", "port": 4, "region": "us-south", "remove_engine_properties": {"configuration": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "jvm": {"coordinator": ["Coordinator"], "worker": ["Worker"]}, "catalog": {"catalog_name": "CatalogName"}}, "size_config": "starter", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "presto", "version": "1.2.0", "worker": {"node_type": "worker", "quantity": 8}}`)
				}))
			})
			It(`Invoke UpdatePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdatePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdatePrestoEngineOptions model with no property values
				updatePrestoEngineOptionsModelNew := new(watsonxdatav2.UpdatePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdatePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PrestoEnginePropertiesCatalog model
				prestoEnginePropertiesCatalogModel := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
				prestoEnginePropertiesCatalogModel.CatalogName = core.StringPtr("testString")

				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the EnginePropertiesOaiGen1Configuration model
				enginePropertiesOaiGen1ConfigurationModel := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
				enginePropertiesOaiGen1ConfigurationModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1ConfigurationModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEnginePropertiesGlobal model
				prestoEnginePropertiesGlobalModel := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
				prestoEnginePropertiesGlobalModel.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

				// Construct an instance of the EnginePropertiesOaiGen1Jvm model
				enginePropertiesOaiGen1JvmModel := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
				enginePropertiesOaiGen1JvmModel.Coordinator = nodeDescriptionBodyModel
				enginePropertiesOaiGen1JvmModel.Worker = nodeDescriptionBodyModel

				// Construct an instance of the PrestoEngineEngineProperties model
				prestoEngineEnginePropertiesModel := new(watsonxdatav2.PrestoEngineEngineProperties)
				prestoEngineEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel
				prestoEngineEnginePropertiesModel.Configuration = enginePropertiesOaiGen1ConfigurationModel
				prestoEngineEnginePropertiesModel.Global = prestoEnginePropertiesGlobalModel
				prestoEngineEnginePropertiesModel.Jvm = enginePropertiesOaiGen1JvmModel

				// Construct an instance of the RemoveEnginePropertiesOaiGenConfiguration model
				removeEnginePropertiesOaiGenConfigurationModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
				removeEnginePropertiesOaiGenConfigurationModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenConfigurationModel.Worker = []string{"testString"}

				// Construct an instance of the RemoveEnginePropertiesOaiGenJvm model
				removeEnginePropertiesOaiGenJvmModel := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
				removeEnginePropertiesOaiGenJvmModel.Coordinator = []string{"testString"}
				removeEnginePropertiesOaiGenJvmModel.Worker = []string{"testString"}

				// Construct an instance of the PrestoEnginePatchRemoveEngineProperties model
				prestoEnginePatchRemoveEnginePropertiesModel := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
				prestoEnginePatchRemoveEnginePropertiesModel.Configuration = removeEnginePropertiesOaiGenConfigurationModel
				prestoEnginePatchRemoveEnginePropertiesModel.Jvm = removeEnginePropertiesOaiGenJvmModel
				prestoEnginePatchRemoveEnginePropertiesModel.Catalog = prestoEnginePropertiesCatalogModel

				// Construct an instance of the PrestoEnginePatch model
				prestoEnginePatchModel := new(watsonxdatav2.PrestoEnginePatch)
				prestoEnginePatchModel.Description = core.StringPtr("updated description for presto engine")
				prestoEnginePatchModel.EngineDisplayName = core.StringPtr("sampleEngine")
				prestoEnginePatchModel.EngineProperties = prestoEngineEnginePropertiesModel
				prestoEnginePatchModel.EngineRestart = core.StringPtr("force")
				prestoEnginePatchModel.RemoveEngineProperties = prestoEnginePatchRemoveEnginePropertiesModel
				prestoEnginePatchModel.Tags = []string{"tag1", "tag2"}
				prestoEnginePatchModelAsPatch, asPatchErr := prestoEnginePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdatePrestoEngineOptions model
				updatePrestoEngineOptionsModel := new(watsonxdatav2.UpdatePrestoEngineOptions)
				updatePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Body = prestoEnginePatchModelAsPatch
				updatePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updatePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdatePrestoEngine(updatePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptions *ListPrestoEngineCatalogsOptions) - Operation response error`, func() {
		listPrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListPrestoEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptions *ListPrestoEngineCatalogsOptions)`, func() {
		listPrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListPrestoEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListPrestoEngineCatalogsWithContext(ctx, listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListPrestoEngineCatalogsWithContext(ctx, listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListPrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListPrestoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListPrestoEngineCatalogsOptions model with no property values
				listPrestoEngineCatalogsOptionsModelNew := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListPrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				listPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.ListPrestoEngineCatalogsOptions)
				listPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListPrestoEngineCatalogs(listPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddPrestoEngineCatalogs(addPrestoEngineCatalogsOptions *AddPrestoEngineCatalogsOptions) - Operation response error`, func() {
		addPrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke AddPrestoEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the AddPrestoEngineCatalogsOptions model
				addPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestoEngineCatalogsOptions)
				addPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.AddPrestoEngineCatalogs(addPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.AddPrestoEngineCatalogs(addPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddPrestoEngineCatalogs(addPrestoEngineCatalogsOptions *AddPrestoEngineCatalogsOptions)`, func() {
		addPrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke AddPrestoEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the AddPrestoEngineCatalogsOptions model
				addPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestoEngineCatalogsOptions)
				addPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.AddPrestoEngineCatalogsWithContext(ctx, addPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.AddPrestoEngineCatalogs(addPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.AddPrestoEngineCatalogsWithContext(ctx, addPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addPrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke AddPrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.AddPrestoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the AddPrestoEngineCatalogsOptions model
				addPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestoEngineCatalogsOptions)
				addPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.AddPrestoEngineCatalogs(addPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke AddPrestoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the AddPrestoEngineCatalogsOptions model
				addPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestoEngineCatalogsOptions)
				addPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.AddPrestoEngineCatalogs(addPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the AddPrestoEngineCatalogsOptions model with no property values
				addPrestoEngineCatalogsOptionsModelNew := new(watsonxdatav2.AddPrestoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.AddPrestoEngineCatalogs(addPrestoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke AddPrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the AddPrestoEngineCatalogsOptions model
				addPrestoEngineCatalogsOptionsModel := new(watsonxdatav2.AddPrestoEngineCatalogsOptions)
				addPrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addPrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.AddPrestoEngineCatalogs(addPrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeletePrestoEngineCatalogs(deletePrestoEngineCatalogsOptions *DeletePrestoEngineCatalogsOptions)`, func() {
		deletePrestoEngineCatalogsPath := "/presto_engines/testString/catalogs"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deletePrestoEngineCatalogsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_names"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeletePrestoEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeletePrestoEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeletePrestoEngineCatalogsOptions model
				deletePrestoEngineCatalogsOptionsModel := new(watsonxdatav2.DeletePrestoEngineCatalogsOptions)
				deletePrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeletePrestoEngineCatalogs(deletePrestoEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeletePrestoEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeletePrestoEngineCatalogsOptions model
				deletePrestoEngineCatalogsOptionsModel := new(watsonxdatav2.DeletePrestoEngineCatalogsOptions)
				deletePrestoEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deletePrestoEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeletePrestoEngineCatalogs(deletePrestoEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeletePrestoEngineCatalogsOptions model with no property values
				deletePrestoEngineCatalogsOptionsModelNew := new(watsonxdatav2.DeletePrestoEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeletePrestoEngineCatalogs(deletePrestoEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestoEngineCatalog(getPrestoEngineCatalogOptions *GetPrestoEngineCatalogOptions) - Operation response error`, func() {
		getPrestoEngineCatalogPath := "/presto_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetPrestoEngineCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetPrestoEngineCatalog(getPrestoEngineCatalogOptions *GetPrestoEngineCatalogOptions)`, func() {
		getPrestoEngineCatalogPath := "/presto_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetPrestoEngineCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetPrestoEngineCatalogWithContext(ctx, getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetPrestoEngineCatalogWithContext(ctx, getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getPrestoEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetPrestoEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetPrestoEngineCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetPrestoEngineCatalogOptions model with no property values
				getPrestoEngineCatalogOptionsModelNew := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetPrestoEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetPrestoEngineCatalogOptions model
				getPrestoEngineCatalogOptionsModel := new(watsonxdatav2.GetPrestoEngineCatalogOptions)
				getPrestoEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getPrestoEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetPrestoEngineCatalog(getPrestoEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PausePrestoEngine(pausePrestoEngineOptions *PausePrestoEngineOptions) - Operation response error`, func() {
		pausePrestoEnginePath := "/presto_engines/testString/pause"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke PausePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`PausePrestoEngine(pausePrestoEngineOptions *PausePrestoEngineOptions)`, func() {
		pausePrestoEnginePath := "/presto_engines/testString/pause"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke PausePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.PausePrestoEngineWithContext(ctx, pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.PausePrestoEngineWithContext(ctx, pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(pausePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke PausePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.PausePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke PausePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the PausePrestoEngineOptions model with no property values
				pausePrestoEngineOptionsModelNew := new(watsonxdatav2.PausePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke PausePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PausePrestoEngineOptions model
				pausePrestoEngineOptionsModel := new(watsonxdatav2.PausePrestoEngineOptions)
				pausePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				pausePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.PausePrestoEngine(pausePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunExplainStatement(runExplainStatementOptions *RunExplainStatementOptions) - Operation response error`, func() {
		runExplainStatementPath := "/presto_engines/testString/query_explain"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RunExplainStatement with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunExplainStatement(runExplainStatementOptions *RunExplainStatementOptions)`, func() {
		runExplainStatementPath := "/presto_engines/testString/query_explain"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "result": "Result"}`)
				}))
			})
			It(`Invoke RunExplainStatement successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RunExplainStatementWithContext(ctx, runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RunExplainStatementWithContext(ctx, runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "result": "Result"}`)
				}))
			})
			It(`Invoke RunExplainStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RunExplainStatement(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RunExplainStatement with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RunExplainStatementOptions model with no property values
				runExplainStatementOptionsModelNew := new(watsonxdatav2.RunExplainStatementOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RunExplainStatement(runExplainStatementOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RunExplainStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainStatementOptions model
				runExplainStatementOptionsModel := new(watsonxdatav2.RunExplainStatementOptions)
				runExplainStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainStatementOptionsModel.Format = core.StringPtr("json")
				runExplainStatementOptionsModel.Type = core.StringPtr("io")
				runExplainStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RunExplainStatement(runExplainStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptions *RunExplainAnalyzeStatementOptions) - Operation response error`, func() {
		runExplainAnalyzeStatementPath := "/presto_engines/testString/query_explain_analyze"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RunExplainAnalyzeStatement with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptions *RunExplainAnalyzeStatementOptions)`, func() {
		runExplainAnalyzeStatementPath := "/presto_engines/testString/query_explain_analyze"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "result": "Result"}`)
				}))
			})
			It(`Invoke RunExplainAnalyzeStatement successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RunExplainAnalyzeStatementWithContext(ctx, runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RunExplainAnalyzeStatementWithContext(ctx, runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(runExplainAnalyzeStatementPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "result": "Result"}`)
				}))
			})
			It(`Invoke RunExplainAnalyzeStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RunExplainAnalyzeStatement with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RunExplainAnalyzeStatementOptions model with no property values
				runExplainAnalyzeStatementOptionsModelNew := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RunExplainAnalyzeStatement successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				runExplainAnalyzeStatementOptionsModel := new(watsonxdatav2.RunExplainAnalyzeStatementOptions)
				runExplainAnalyzeStatementOptionsModel.EngineID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Statement = core.StringPtr("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.Verbose = core.BoolPtr(true)
				runExplainAnalyzeStatementOptionsModel.AuthInstanceID = core.StringPtr("testString")
				runExplainAnalyzeStatementOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RunExplainAnalyzeStatement(runExplainAnalyzeStatementOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RestartPrestoEngine(restartPrestoEngineOptions *RestartPrestoEngineOptions) - Operation response error`, func() {
		restartPrestoEnginePath := "/presto_engines/testString/restart"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RestartPrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RestartPrestoEngine(restartPrestoEngineOptions *RestartPrestoEngineOptions)`, func() {
		restartPrestoEnginePath := "/presto_engines/testString/restart"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke RestartPrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RestartPrestoEngineWithContext(ctx, restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RestartPrestoEngineWithContext(ctx, restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(restartPrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke RestartPrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RestartPrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RestartPrestoEngineOptions model with no property values
				restartPrestoEngineOptionsModelNew := new(watsonxdatav2.RestartPrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RestartPrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RestartPrestoEngineOptions model
				restartPrestoEngineOptionsModel := new(watsonxdatav2.RestartPrestoEngineOptions)
				restartPrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				restartPrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RestartPrestoEngine(restartPrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumePrestoEngine(resumePrestoEngineOptions *ResumePrestoEngineOptions) - Operation response error`, func() {
		resumePrestoEnginePath := "/presto_engines/testString/resume"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ResumePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ResumePrestoEngine(resumePrestoEngineOptions *ResumePrestoEngineOptions)`, func() {
		resumePrestoEnginePath := "/presto_engines/testString/resume"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke ResumePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ResumePrestoEngineWithContext(ctx, resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ResumePrestoEngineWithContext(ctx, resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(resumePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke ResumePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ResumePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ResumePrestoEngineOptions model with no property values
				resumePrestoEngineOptionsModelNew := new(watsonxdatav2.ResumePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ResumePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ResumePrestoEngineOptions model
				resumePrestoEngineOptionsModel := new(watsonxdatav2.ResumePrestoEngineOptions)
				resumePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				resumePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ResumePrestoEngine(resumePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScalePrestoEngine(scalePrestoEngineOptions *ScalePrestoEngineOptions) - Operation response error`, func() {
		scalePrestoEnginePath := "/presto_engines/testString/scale"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ScalePrestoEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ScalePrestoEngine(scalePrestoEngineOptions *ScalePrestoEngineOptions)`, func() {
		scalePrestoEnginePath := "/presto_engines/testString/scale"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke ScalePrestoEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ScalePrestoEngineWithContext(ctx, scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ScalePrestoEngineWithContext(ctx, scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(scalePrestoEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke ScalePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ScalePrestoEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ScalePrestoEngineOptions model with no property values
				scalePrestoEngineOptionsModelNew := new(watsonxdatav2.ScalePrestoEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke ScalePrestoEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))

				// Construct an instance of the ScalePrestoEngineOptions model
				scalePrestoEngineOptionsModel := new(watsonxdatav2.ScalePrestoEngineOptions)
				scalePrestoEngineOptionsModel.EngineID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Coordinator = nodeDescriptionModel
				scalePrestoEngineOptionsModel.Worker = nodeDescriptionModel
				scalePrestoEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				scalePrestoEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ScalePrestoEngine(scalePrestoEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngines(listSparkEnginesOptions *ListSparkEnginesOptions) - Operation response error`, func() {
		listSparkEnginesPath := "/spark_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEnginesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSparkEngines with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngines(listSparkEnginesOptions *ListSparkEnginesOptions)`, func() {
		listSparkEnginesPath := "/spark_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"spark_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}]}`)
				}))
			})
			It(`Invoke ListSparkEngines successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSparkEnginesWithContext(ctx, listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSparkEnginesWithContext(ctx, listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEnginesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"spark_engines": [{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}]}`)
				}))
			})
			It(`Invoke ListSparkEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSparkEngines(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSparkEngines with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSparkEngines successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := new(watsonxdatav2.ListSparkEnginesOptions)
				listSparkEnginesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEnginesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSparkEngines(listSparkEnginesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngine(createSparkEngineOptions *CreateSparkEngineOptions) - Operation response error`, func() {
		createSparkEnginePath := "/spark_engines"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSparkEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngine(createSparkEngineOptions *CreateSparkEngineOptions)`, func() {
		createSparkEnginePath := "/spark_engines"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke CreateSparkEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSparkEngineWithContext(ctx, createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSparkEngineWithContext(ctx, createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEnginePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke CreateSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSparkEngineOptions model with no property values
				createSparkEngineOptionsModelNew := new(watsonxdatav2.CreateSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke CreateSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsModel := new(watsonxdatav2.CreateSparkEngineOptions)
				createSparkEngineOptionsModel.Origin = core.StringPtr("native")
				createSparkEngineOptionsModel.AssociatedCatalogs = []string{"iceberg_data"}
				createSparkEngineOptionsModel.Description = core.StringPtr("testString")
				createSparkEngineOptionsModel.EngineDetails = sparkEngineDetailsPrototypeModel
				createSparkEngineOptionsModel.EngineDisplayName = core.StringPtr("test-native")
				createSparkEngineOptionsModel.Status = core.StringPtr("testString")
				createSparkEngineOptionsModel.Tags = []string{"testString"}
				createSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSparkEngine(createSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngine(getSparkEngineOptions *GetSparkEngineOptions) - Operation response error`, func() {
		getSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEnginePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSparkEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngine(getSparkEngineOptions *GetSparkEngineOptions)`, func() {
		getSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke GetSparkEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSparkEngineWithContext(ctx, getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSparkEngineWithContext(ctx, getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEnginePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke GetSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSparkEngineOptions model with no property values
				getSparkEngineOptionsModelNew := new(watsonxdatav2.GetSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSparkEngine(getSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineOptions model
				getSparkEngineOptionsModel := new(watsonxdatav2.GetSparkEngineOptions)
				getSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSparkEngine(getSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSparkEngine(deleteSparkEngineOptions *DeleteSparkEngineOptions)`, func() {
		deleteSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSparkEnginePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSparkEngineOptions model
				deleteSparkEngineOptionsModel := new(watsonxdatav2.DeleteSparkEngineOptions)
				deleteSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSparkEngine(deleteSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSparkEngineOptions model
				deleteSparkEngineOptionsModel := new(watsonxdatav2.DeleteSparkEngineOptions)
				deleteSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSparkEngine(deleteSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSparkEngineOptions model with no property values
				deleteSparkEngineOptionsModelNew := new(watsonxdatav2.DeleteSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSparkEngine(deleteSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSparkEngine(updateSparkEngineOptions *UpdateSparkEngineOptions) - Operation response error`, func() {
		updateSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSparkEnginePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateSparkEngine with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSparkEngine(updateSparkEngineOptions *UpdateSparkEngineOptions)`, func() {
		updateSparkEnginePath := "/spark_engines/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSparkEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke UpdateSparkEngine successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateSparkEngineWithContext(ctx, updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateSparkEngineWithContext(ctx, updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSparkEnginePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_catalogs": ["AssociatedCatalogs"], "build_version": "1.0.3.0.0", "created_by": "<username>@<domain>.com", "created_on": 9, "description": "spark engine for running sql queries", "engine_details": {"api_key": "apikey", "connection_string": "https://xyz.<region>.ae.cloud.123.com/v3/analytics_engines/<spark_iae_id>", "default_config": {"config1": "Config1", "config2": "Config2"}, "default_version": "4.8.3", "endpoints": {"applications_api": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>", "history_server_endpoint": "$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server", "spark_access_endpoint": "$HOST/analytics-engine/details/spark-<instance_id>", "spark_jobs_v4_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications", "spark_kernel_endpoint": "$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels", "view_history_server": "ViewHistoryServer", "wxd_application_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications", "wxd_engine_endpoint": "$HOST/v1/1698311655308796/engines/spark817", "wxd_history_server_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server", "wxd_history_server_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/history_server/ui"}, "engine_home_bucket_display_name": "test-spark-bucket", "engine_home_bucket_name": "test-spark-bucket", "engine_home_path": "spark/spark1234", "engine_home_volume": "test-spark-volume", "engine_home_volume_id": "1704979825978585", "engine_home_volume_name": "my-volume", "engine_home_volume_storage_class": "nfs-client", "engine_home_volume_storage_size": "5Gi", "instance_id": "spark-id", "managed_by": "fully/self", "scale_config": {"auto_scale_enabled": true, "current_number_of_nodes": 2, "maximum_number_of_nodes": 5, "minimum_number_of_nodes": 1, "node_type": "medium", "number_of_nodes": 2}}, "engine_display_name": "sampleEngine", "engine_id": "sampleEngine123", "origin": "external", "status": "Registered", "tags": ["Tags"], "type": "spark"}`)
				}))
			})
			It(`Invoke UpdateSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateSparkEngine with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateSparkEngineOptions model with no property values
				updateSparkEngineOptionsModelNew := new(watsonxdatav2.UpdateSparkEngineOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateSparkEngine successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the UpdateSparkEngineBodyEngineDetails model
				updateSparkEngineBodyEngineDetailsModel := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
				updateSparkEngineBodyEngineDetailsModel.DefaultConfig = map[string]string{"key1": "testString"}
				updateSparkEngineBodyEngineDetailsModel.DefaultVersion = core.StringPtr("3.4")

				// Construct an instance of the UpdateSparkEngineBody model
				updateSparkEngineBodyModel := new(watsonxdatav2.UpdateSparkEngineBody)
				updateSparkEngineBodyModel.Description = core.StringPtr("Updated Description")
				updateSparkEngineBodyModel.EngineDetails = updateSparkEngineBodyEngineDetailsModel
				updateSparkEngineBodyModel.EngineDisplayName = core.StringPtr("Updated Display Name")
				updateSparkEngineBodyModel.Tags = []string{"tag1", "tag2"}
				updateSparkEngineBodyModelAsPatch, asPatchErr := updateSparkEngineBodyModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSparkEngineOptions model
				updateSparkEngineOptionsModel := new(watsonxdatav2.UpdateSparkEngineOptions)
				updateSparkEngineOptionsModel.EngineID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Body = updateSparkEngineBodyModelAsPatch
				updateSparkEngineOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSparkEngineOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateSparkEngine(updateSparkEngineOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngineApplications(listSparkEngineApplicationsOptions *ListSparkEngineApplicationsOptions) - Operation response error`, func() {
		listSparkEngineApplicationsPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineApplicationsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSparkEngineApplications with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngineApplications(listSparkEngineApplicationsOptions *ListSparkEngineApplicationsOptions)`, func() {
		listSparkEngineApplicationsPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineApplicationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"applications": [{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3"}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}]}`)
				}))
			})
			It(`Invoke ListSparkEngineApplications successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSparkEngineApplicationsWithContext(ctx, listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSparkEngineApplicationsWithContext(ctx, listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineApplicationsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"applications": [{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3"}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}]}`)
				}))
			})
			It(`Invoke ListSparkEngineApplications successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSparkEngineApplications with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListSparkEngineApplicationsOptions model with no property values
				listSparkEngineApplicationsOptionsModelNew := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSparkEngineApplications successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineApplicationsOptions model
				listSparkEngineApplicationsOptionsModel := new(watsonxdatav2.ListSparkEngineApplicationsOptions)
				listSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				listSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSparkEngineApplications(listSparkEngineApplicationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineApplication(createSparkEngineApplicationOptions *CreateSparkEngineApplicationOptions) - Operation response error`, func() {
		createSparkEngineApplicationPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineApplicationPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSparkEngineApplication with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineApplication(createSparkEngineApplicationOptions *CreateSparkEngineApplicationOptions)`, func() {
		createSparkEngineApplicationPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineApplicationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3"}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}`)
				}))
			})
			It(`Invoke CreateSparkEngineApplication successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSparkEngineApplicationWithContext(ctx, createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSparkEngineApplicationWithContext(ctx, createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineApplicationPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3"}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}`)
				}))
			})
			It(`Invoke CreateSparkEngineApplication successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSparkEngineApplication with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSparkEngineApplicationOptions model with no property values
				createSparkEngineApplicationOptionsModelNew := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSparkEngineApplication successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				createSparkEngineApplicationOptionsModel := new(watsonxdatav2.CreateSparkEngineApplicationOptions)
				createSparkEngineApplicationOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ApplicationDetails = sparkApplicationDetailsModel
				createSparkEngineApplicationOptionsModel.JobEndpoint = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.ServiceInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.Type = core.StringPtr("iae")
				createSparkEngineApplicationOptionsModel.Volumes = []watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}
				createSparkEngineApplicationOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineApplicationOptionsModel.State = []string{"testString"}
				createSparkEngineApplicationOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSparkEngineApplication(createSparkEngineApplicationOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSparkEngineApplications(deleteSparkEngineApplicationsOptions *DeleteSparkEngineApplicationsOptions)`, func() {
		deleteSparkEngineApplicationsPath := "/spark_engines/testString/applications"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSparkEngineApplicationsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["application_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSparkEngineApplications successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSparkEngineApplications(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSparkEngineApplicationsOptions model
				deleteSparkEngineApplicationsOptionsModel := new(watsonxdatav2.DeleteSparkEngineApplicationsOptions)
				deleteSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.ApplicationID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				deleteSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSparkEngineApplications(deleteSparkEngineApplicationsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSparkEngineApplications with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSparkEngineApplicationsOptions model
				deleteSparkEngineApplicationsOptionsModel := new(watsonxdatav2.DeleteSparkEngineApplicationsOptions)
				deleteSparkEngineApplicationsOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.ApplicationID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineApplicationsOptionsModel.State = []string{"testString"}
				deleteSparkEngineApplicationsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSparkEngineApplications(deleteSparkEngineApplicationsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSparkEngineApplicationsOptions model with no property values
				deleteSparkEngineApplicationsOptionsModelNew := new(watsonxdatav2.DeleteSparkEngineApplicationsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSparkEngineApplications(deleteSparkEngineApplicationsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptions *GetSparkEngineApplicationStatusOptions) - Operation response error`, func() {
		getSparkEngineApplicationStatusPath := "/spark_engines/testString/applications/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineApplicationStatusPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSparkEngineApplicationStatus with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptions *GetSparkEngineApplicationStatusOptions)`, func() {
		getSparkEngineApplicationStatusPath := "/spark_engines/testString/applications/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineApplicationStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3"}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}`)
				}))
			})
			It(`Invoke GetSparkEngineApplicationStatus successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSparkEngineApplicationStatusWithContext(ctx, getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSparkEngineApplicationStatusWithContext(ctx, getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineApplicationStatusPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"application_details": {"application": "s3://mybucket/wordcount.py", "arguments": ["people.txt"], "class": "org.apache.spark.examples.SparkPi", "conf": {"spark_sample_config_properpty": "SparkSampleConfigProperpty"}, "env": {"sample_env_key": "SampleEnvKey"}, "files": "s3://mybucket/myfile.txt", "jars": "Jars", "name": "SparkApplicaton1", "packages": "org.apache.spark:example_1.2.3", "repositories": "https://repo1.maven.org/maven2/", "spark_version": "3.3"}, "application_id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "auto_termination_time": "2020-12-08T10:00:00.000Z", "creation_time": "Saturday 28 October 2023 07:17:06.856+0000", "deploy_mode": "stand-alone", "end_time": "2020-12-08T10:00:00.000Z", "failed_time": "FailedTime", "finish_time": "Saturday 28 October 2023 07:17:38.966+0000", "id": "cd7cbf1f-8893-4c51-aa3d-d92729f05e99", "job_endpoint": "<host>/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/engine_applications", "return_code": "0", "runtime": {"spark_version": "3.3"}, "service_instance_id": "ServiceInstanceID", "spark_application_id": "app-20231028071726-0000", "spark_application_name": "PythonWordCount", "spark_version": "3.3", "start_time": "Saturday 28 October 2023 07:17:26.649+0000", "state": "FINISHED", "state_details": [{"code": "Code", "message": "Message", "type": "Type"}], "submission_time": "2023-11-01T11:18:49.758Z", "template_id": "spark-3.3-jaas-v2-cp4d-template", "type": "iae", "volumes": [{"mount_path": "/mount/path", "name": "my-volume", "read_only": true, "source_sub_path": "/source/path"}], "wxd_application_ui_endpoint": "$HOST/v1/1698311655308796/engines/spark817/applications/c7b3fccf-badb-46b0-b1ef-9b3154424021/ui"}`)
				}))
			})
			It(`Invoke GetSparkEngineApplicationStatus successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSparkEngineApplicationStatus with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSparkEngineApplicationStatusOptions model with no property values
				getSparkEngineApplicationStatusOptionsModelNew := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSparkEngineApplicationStatus successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				getSparkEngineApplicationStatusOptionsModel := new(watsonxdatav2.GetSparkEngineApplicationStatusOptions)
				getSparkEngineApplicationStatusOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.ApplicationID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineApplicationStatusOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSparkEngineApplicationStatus(getSparkEngineApplicationStatusOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngineCatalogs(listSparkEngineCatalogsOptions *ListSparkEngineCatalogsOptions) - Operation response error`, func() {
		listSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSparkEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkEngineCatalogs(listSparkEngineCatalogsOptions *ListSparkEngineCatalogsOptions)`, func() {
		listSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListSparkEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSparkEngineCatalogsWithContext(ctx, listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSparkEngineCatalogsWithContext(ctx, listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSparkEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListSparkEngineCatalogsOptions model with no property values
				listSparkEngineCatalogsOptionsModelNew := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkEngineCatalogsOptions model
				listSparkEngineCatalogsOptionsModel := new(watsonxdatav2.ListSparkEngineCatalogsOptions)
				listSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSparkEngineCatalogs(listSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddSparkEngineCatalogs(addSparkEngineCatalogsOptions *AddSparkEngineCatalogsOptions) - Operation response error`, func() {
		addSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke AddSparkEngineCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the AddSparkEngineCatalogsOptions model
				addSparkEngineCatalogsOptionsModel := new(watsonxdatav2.AddSparkEngineCatalogsOptions)
				addSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.AddSparkEngineCatalogs(addSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.AddSparkEngineCatalogs(addSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`AddSparkEngineCatalogs(addSparkEngineCatalogsOptions *AddSparkEngineCatalogsOptions)`, func() {
		addSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke AddSparkEngineCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the AddSparkEngineCatalogsOptions model
				addSparkEngineCatalogsOptionsModel := new(watsonxdatav2.AddSparkEngineCatalogsOptions)
				addSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.AddSparkEngineCatalogsWithContext(ctx, addSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.AddSparkEngineCatalogs(addSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.AddSparkEngineCatalogsWithContext(ctx, addSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(addSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke AddSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.AddSparkEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the AddSparkEngineCatalogsOptions model
				addSparkEngineCatalogsOptionsModel := new(watsonxdatav2.AddSparkEngineCatalogsOptions)
				addSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.AddSparkEngineCatalogs(addSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke AddSparkEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the AddSparkEngineCatalogsOptions model
				addSparkEngineCatalogsOptionsModel := new(watsonxdatav2.AddSparkEngineCatalogsOptions)
				addSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.AddSparkEngineCatalogs(addSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the AddSparkEngineCatalogsOptions model with no property values
				addSparkEngineCatalogsOptionsModelNew := new(watsonxdatav2.AddSparkEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.AddSparkEngineCatalogs(addSparkEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke AddSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the AddSparkEngineCatalogsOptions model
				addSparkEngineCatalogsOptionsModel := new(watsonxdatav2.AddSparkEngineCatalogsOptions)
				addSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				addSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.AddSparkEngineCatalogs(addSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSparkEngineCatalogs(deleteSparkEngineCatalogsOptions *DeleteSparkEngineCatalogsOptions)`, func() {
		deleteSparkEngineCatalogsPath := "/spark_engines/testString/catalogs"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSparkEngineCatalogsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["catalog_names"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSparkEngineCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSparkEngineCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSparkEngineCatalogsOptions model
				deleteSparkEngineCatalogsOptionsModel := new(watsonxdatav2.DeleteSparkEngineCatalogsOptions)
				deleteSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSparkEngineCatalogs(deleteSparkEngineCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSparkEngineCatalogs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSparkEngineCatalogsOptions model
				deleteSparkEngineCatalogsOptionsModel := new(watsonxdatav2.DeleteSparkEngineCatalogsOptions)
				deleteSparkEngineCatalogsOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.CatalogNames = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSparkEngineCatalogs(deleteSparkEngineCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSparkEngineCatalogsOptions model with no property values
				deleteSparkEngineCatalogsOptionsModelNew := new(watsonxdatav2.DeleteSparkEngineCatalogsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSparkEngineCatalogs(deleteSparkEngineCatalogsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineCatalog(getSparkEngineCatalogOptions *GetSparkEngineCatalogOptions) - Operation response error`, func() {
		getSparkEngineCatalogPath := "/spark_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSparkEngineCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineCatalog(getSparkEngineCatalogOptions *GetSparkEngineCatalogOptions)`, func() {
		getSparkEngineCatalogPath := "/spark_engines/testString/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetSparkEngineCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSparkEngineCatalogWithContext(ctx, getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSparkEngineCatalogWithContext(ctx, getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetSparkEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSparkEngineCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSparkEngineCatalogOptions model with no property values
				getSparkEngineCatalogOptionsModelNew := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSparkEngineCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineCatalogOptions model
				getSparkEngineCatalogOptionsModel := new(watsonxdatav2.GetSparkEngineCatalogOptions)
				getSparkEngineCatalogOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSparkEngineCatalog(getSparkEngineCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptions *GetSparkEngineHistoryServerOptions) - Operation response error`, func() {
		getSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetSparkEngineHistoryServer with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptions *GetSparkEngineHistoryServerOptions)`, func() {
		getSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"auto_termination_time": "2022-02-24T07:37:47Z", "cores": "1", "memory": "4G", "start_time": "2022-02-21T07:37:47Z", "state": "started"}`)
				}))
			})
			It(`Invoke GetSparkEngineHistoryServer successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetSparkEngineHistoryServerWithContext(ctx, getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetSparkEngineHistoryServerWithContext(ctx, getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"auto_termination_time": "2022-02-24T07:37:47Z", "cores": "1", "memory": "4G", "start_time": "2022-02-21T07:37:47Z", "state": "started"}`)
				}))
			})
			It(`Invoke GetSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetSparkEngineHistoryServer with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetSparkEngineHistoryServerOptions model with no property values
				getSparkEngineHistoryServerOptionsModelNew := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				getSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.GetSparkEngineHistoryServerOptions)
				getSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetSparkEngineHistoryServer(getSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptions *StartSparkEngineHistoryServerOptions) - Operation response error`, func() {
		startSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(startSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke StartSparkEngineHistoryServer with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptions *StartSparkEngineHistoryServerOptions)`, func() {
		startSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(startSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"auto_termination_time": "2022-02-24T07:37:47Z", "cores": "1", "memory": "4G", "start_time": "2022-02-21T07:37:47Z", "state": "started"}`)
				}))
			})
			It(`Invoke StartSparkEngineHistoryServer successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.StartSparkEngineHistoryServerWithContext(ctx, startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.StartSparkEngineHistoryServerWithContext(ctx, startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(startSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"auto_termination_time": "2022-02-24T07:37:47Z", "cores": "1", "memory": "4G", "start_time": "2022-02-21T07:37:47Z", "state": "started"}`)
				}))
			})
			It(`Invoke StartSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke StartSparkEngineHistoryServer with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the StartSparkEngineHistoryServerOptions model with no property values
				startSparkEngineHistoryServerOptionsModelNew := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke StartSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				startSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.StartSparkEngineHistoryServerOptions)
				startSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Cores = core.StringPtr("1")
				startSparkEngineHistoryServerOptionsModel.Memory = core.StringPtr("4G")
				startSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				startSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.StartSparkEngineHistoryServer(startSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSparkEngineHistoryServer(deleteSparkEngineHistoryServerOptions *DeleteSparkEngineHistoryServerOptions)`, func() {
		deleteSparkEngineHistoryServerPath := "/spark_engines/testString/history_server"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSparkEngineHistoryServerPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSparkEngineHistoryServer successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSparkEngineHistoryServer(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSparkEngineHistoryServerOptions model
				deleteSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.DeleteSparkEngineHistoryServerOptions)
				deleteSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSparkEngineHistoryServer(deleteSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSparkEngineHistoryServer with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSparkEngineHistoryServerOptions model
				deleteSparkEngineHistoryServerOptionsModel := new(watsonxdatav2.DeleteSparkEngineHistoryServerOptions)
				deleteSparkEngineHistoryServerOptionsModel.EngineID = core.StringPtr("testString")
				deleteSparkEngineHistoryServerOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSparkEngineHistoryServerOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSparkEngineHistoryServer(deleteSparkEngineHistoryServerOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSparkEngineHistoryServerOptions model with no property values
				deleteSparkEngineHistoryServerOptionsModelNew := new(watsonxdatav2.DeleteSparkEngineHistoryServerOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSparkEngineHistoryServer(deleteSparkEngineHistoryServerOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEnginePause(createSparkEnginePauseOptions *CreateSparkEnginePauseOptions) - Operation response error`, func() {
		createSparkEnginePausePath := "/spark_engines/testString/pause"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEnginePausePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSparkEnginePause with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEnginePauseOptions model
				createSparkEnginePauseOptionsModel := new(watsonxdatav2.CreateSparkEnginePauseOptions)
				createSparkEnginePauseOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSparkEnginePause(createSparkEnginePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSparkEnginePause(createSparkEnginePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEnginePause(createSparkEnginePauseOptions *CreateSparkEnginePauseOptions)`, func() {
		createSparkEnginePausePath := "/spark_engines/testString/pause"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEnginePausePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateSparkEnginePause successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateSparkEnginePauseOptions model
				createSparkEnginePauseOptionsModel := new(watsonxdatav2.CreateSparkEnginePauseOptions)
				createSparkEnginePauseOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSparkEnginePauseWithContext(ctx, createSparkEnginePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSparkEnginePause(createSparkEnginePauseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSparkEnginePauseWithContext(ctx, createSparkEnginePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEnginePausePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateSparkEnginePause successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSparkEnginePause(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateSparkEnginePauseOptions model
				createSparkEnginePauseOptionsModel := new(watsonxdatav2.CreateSparkEnginePauseOptions)
				createSparkEnginePauseOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSparkEnginePause(createSparkEnginePauseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSparkEnginePause with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEnginePauseOptions model
				createSparkEnginePauseOptionsModel := new(watsonxdatav2.CreateSparkEnginePauseOptions)
				createSparkEnginePauseOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSparkEnginePause(createSparkEnginePauseOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSparkEnginePauseOptions model with no property values
				createSparkEnginePauseOptionsModelNew := new(watsonxdatav2.CreateSparkEnginePauseOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSparkEnginePause(createSparkEnginePauseOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSparkEnginePause successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEnginePauseOptions model
				createSparkEnginePauseOptionsModel := new(watsonxdatav2.CreateSparkEnginePauseOptions)
				createSparkEnginePauseOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEnginePauseOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSparkEnginePause(createSparkEnginePauseOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineResume(createSparkEngineResumeOptions *CreateSparkEngineResumeOptions) - Operation response error`, func() {
		createSparkEngineResumePath := "/spark_engines/testString/resume"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineResumePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSparkEngineResume with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEngineResumeOptions model
				createSparkEngineResumeOptionsModel := new(watsonxdatav2.CreateSparkEngineResumeOptions)
				createSparkEngineResumeOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSparkEngineResume(createSparkEngineResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSparkEngineResume(createSparkEngineResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineResume(createSparkEngineResumeOptions *CreateSparkEngineResumeOptions)`, func() {
		createSparkEngineResumePath := "/spark_engines/testString/resume"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineResumePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateSparkEngineResume successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateSparkEngineResumeOptions model
				createSparkEngineResumeOptionsModel := new(watsonxdatav2.CreateSparkEngineResumeOptions)
				createSparkEngineResumeOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSparkEngineResumeWithContext(ctx, createSparkEngineResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSparkEngineResume(createSparkEngineResumeOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSparkEngineResumeWithContext(ctx, createSparkEngineResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineResumePath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateSparkEngineResume successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSparkEngineResume(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateSparkEngineResumeOptions model
				createSparkEngineResumeOptionsModel := new(watsonxdatav2.CreateSparkEngineResumeOptions)
				createSparkEngineResumeOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineResume(createSparkEngineResumeOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSparkEngineResume with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEngineResumeOptions model
				createSparkEngineResumeOptionsModel := new(watsonxdatav2.CreateSparkEngineResumeOptions)
				createSparkEngineResumeOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSparkEngineResume(createSparkEngineResumeOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSparkEngineResumeOptions model with no property values
				createSparkEngineResumeOptionsModelNew := new(watsonxdatav2.CreateSparkEngineResumeOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineResume(createSparkEngineResumeOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSparkEngineResume successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEngineResumeOptions model
				createSparkEngineResumeOptionsModel := new(watsonxdatav2.CreateSparkEngineResumeOptions)
				createSparkEngineResumeOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineResumeOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSparkEngineResume(createSparkEngineResumeOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineScale(createSparkEngineScaleOptions *CreateSparkEngineScaleOptions) - Operation response error`, func() {
		createSparkEngineScalePath := "/spark_engines/testString/scale"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineScalePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSparkEngineScale with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEngineScaleOptions model
				createSparkEngineScaleOptionsModel := new(watsonxdatav2.CreateSparkEngineScaleOptions)
				createSparkEngineScaleOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				createSparkEngineScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSparkEngineScale(createSparkEngineScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSparkEngineScale(createSparkEngineScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSparkEngineScale(createSparkEngineScaleOptions *CreateSparkEngineScaleOptions)`, func() {
		createSparkEngineScalePath := "/spark_engines/testString/scale"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineScalePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateSparkEngineScale successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateSparkEngineScaleOptions model
				createSparkEngineScaleOptionsModel := new(watsonxdatav2.CreateSparkEngineScaleOptions)
				createSparkEngineScaleOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				createSparkEngineScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSparkEngineScaleWithContext(ctx, createSparkEngineScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSparkEngineScale(createSparkEngineScaleOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSparkEngineScaleWithContext(ctx, createSparkEngineScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSparkEngineScalePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"message": "Message", "message_code": "MessageCode"}`)
				}))
			})
			It(`Invoke CreateSparkEngineScale successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSparkEngineScale(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateSparkEngineScaleOptions model
				createSparkEngineScaleOptionsModel := new(watsonxdatav2.CreateSparkEngineScaleOptions)
				createSparkEngineScaleOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				createSparkEngineScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineScale(createSparkEngineScaleOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSparkEngineScale with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEngineScaleOptions model
				createSparkEngineScaleOptionsModel := new(watsonxdatav2.CreateSparkEngineScaleOptions)
				createSparkEngineScaleOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				createSparkEngineScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSparkEngineScale(createSparkEngineScaleOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSparkEngineScaleOptions model with no property values
				createSparkEngineScaleOptionsModelNew := new(watsonxdatav2.CreateSparkEngineScaleOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSparkEngineScale(createSparkEngineScaleOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSparkEngineScale successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSparkEngineScaleOptions model
				createSparkEngineScaleOptionsModel := new(watsonxdatav2.CreateSparkEngineScaleOptions)
				createSparkEngineScaleOptionsModel.EngineID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.NumberOfNodes = core.Int64Ptr(int64(2))
				createSparkEngineScaleOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSparkEngineScaleOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSparkEngineScale(createSparkEngineScaleOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkVersions(listSparkVersionsOptions *ListSparkVersionsOptions) - Operation response error`, func() {
		listSparkVersionsPath := "/spark_versions"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkVersionsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSparkVersions with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSparkVersions(listSparkVersionsOptions *ListSparkVersionsOptions)`, func() {
		listSparkVersionsPath := "/spark_versions"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkVersionsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "spark_versions": [{"display_name": "Instance Name"}]}`)
				}))
			})
			It(`Invoke ListSparkVersions successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSparkVersionsWithContext(ctx, listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSparkVersionsWithContext(ctx, listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSparkVersionsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "spark_versions": [{"display_name": "Instance Name"}]}`)
				}))
			})
			It(`Invoke ListSparkVersions successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSparkVersions(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSparkVersions with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSparkVersions successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := new(watsonxdatav2.ListSparkVersionsOptions)
				listSparkVersionsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSparkVersionsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSparkVersions(listSparkVersionsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogs(listCatalogsOptions *ListCatalogsOptions) - Operation response error`, func() {
		listCatalogsPath := "/catalogs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListCatalogs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListCatalogs(listCatalogsOptions *ListCatalogsOptions)`, func() {
		listCatalogsPath := "/catalogs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListCatalogs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListCatalogsWithContext(ctx, listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListCatalogsWithContext(ctx, listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listCatalogsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"catalogs": [{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}]}`)
				}))
			})
			It(`Invoke ListCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListCatalogs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListCatalogs with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListCatalogs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := new(watsonxdatav2.ListCatalogsOptions)
				listCatalogsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listCatalogsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListCatalogs(listCatalogsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalog(getCatalogOptions *GetCatalogOptions) - Operation response error`, func() {
		getCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetCatalog(getCatalogOptions *GetCatalogOptions)`, func() {
		getCatalogPath := "/catalogs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetCatalogWithContext(ctx, getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetCatalogWithContext(ctx, getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getCatalogPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "associated_buckets": ["AssociatedBuckets"], "associated_databases": ["AssociatedDatabases"], "associated_engines": ["AssociatedEngines"], "catalog_name": "sampleCatalog", "catalog_type": "iceberg", "created_by": "<username>@<domain>.com", "created_on": "1602839833", "description": "Iceberg catalog description", "hostname": "s3a://samplehost.com", "last_sync_at": "1602839833", "managed_by": "ibm", "metastore": "glue", "port": "3232", "status": "running", "sync_description": "Table registration was successful", "sync_exception": ["SyncException"], "sync_status": "SUCCESS", "tags": ["Tags"], "thrift_uri": "thrift://samplehost-catalog:4354"}`)
				}))
			})
			It(`Invoke GetCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetCatalogOptions model with no property values
				getCatalogOptionsModelNew := new(watsonxdatav2.GetCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetCatalog(getCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetCatalogOptions model
				getCatalogOptionsModel := new(watsonxdatav2.GetCatalogOptions)
				getCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				getCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetCatalog(getCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSchemas(listSchemasOptions *ListSchemasOptions) - Operation response error`, func() {
		listSchemasPath := "/catalogs/testString/schemas"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSchemasPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListSchemas with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListSchemas(listSchemasOptions *ListSchemasOptions)`, func() {
		listSchemasPath := "/catalogs/testString/schemas"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSchemasPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "schemas": ["Schemas"]}`)
				}))
			})
			It(`Invoke ListSchemas successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListSchemasWithContext(ctx, listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListSchemasWithContext(ctx, listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listSchemasPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}, "schemas": ["Schemas"]}`)
				}))
			})
			It(`Invoke ListSchemas successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListSchemas(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListSchemas with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListSchemasOptions model with no property values
				listSchemasOptionsModelNew := new(watsonxdatav2.ListSchemasOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListSchemas(listSchemasOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListSchemas successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListSchemasOptions model
				listSchemasOptionsModel := new(watsonxdatav2.ListSchemasOptions)
				listSchemasOptionsModel.EngineID = core.StringPtr("testString")
				listSchemasOptionsModel.CatalogID = core.StringPtr("testString")
				listSchemasOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listSchemasOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListSchemas(listSchemasOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSchema(createSchemaOptions *CreateSchemaOptions) - Operation response error`, func() {
		createSchemaPath := "/catalogs/testString/schemas"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSchemaPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateSchema with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateSchema(createSchemaOptions *CreateSchemaOptions)`, func() {
		createSchemaPath := "/catalogs/testString/schemas"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSchemaPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke CreateSchema successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateSchemaWithContext(ctx, createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateSchemaWithContext(ctx, createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createSchemaPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke CreateSchema successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateSchema(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateSchema with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateSchemaOptions model with no property values
				createSchemaOptionsModelNew := new(watsonxdatav2.CreateSchemaOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateSchema(createSchemaOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateSchema successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateSchemaOptions model
				createSchemaOptionsModel := new(watsonxdatav2.CreateSchemaOptions)
				createSchemaOptionsModel.EngineID = core.StringPtr("testString")
				createSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				createSchemaOptionsModel.CustomPath = core.StringPtr("sample-path")
				createSchemaOptionsModel.SchemaName = core.StringPtr("SampleSchema1")
				createSchemaOptionsModel.BucketName = core.StringPtr("sample-bucket")
				createSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateSchema(createSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteSchema(deleteSchemaOptions *DeleteSchemaOptions)`, func() {
		deleteSchemaPath := "/catalogs/testString/schemas/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteSchemaPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteSchema successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteSchema(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteSchemaOptions model
				deleteSchemaOptionsModel := new(watsonxdatav2.DeleteSchemaOptions)
				deleteSchemaOptionsModel.EngineID = core.StringPtr("testString")
				deleteSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				deleteSchemaOptionsModel.SchemaID = core.StringPtr("testString")
				deleteSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteSchema(deleteSchemaOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteSchema with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteSchemaOptions model
				deleteSchemaOptionsModel := new(watsonxdatav2.DeleteSchemaOptions)
				deleteSchemaOptionsModel.EngineID = core.StringPtr("testString")
				deleteSchemaOptionsModel.CatalogID = core.StringPtr("testString")
				deleteSchemaOptionsModel.SchemaID = core.StringPtr("testString")
				deleteSchemaOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteSchemaOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteSchema(deleteSchemaOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteSchemaOptions model with no property values
				deleteSchemaOptionsModelNew := new(watsonxdatav2.DeleteSchemaOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteSchema(deleteSchemaOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListTables(listTablesOptions *ListTablesOptions) - Operation response error`, func() {
		listTablesPath := "/catalogs/testString/schemas/testString/tables"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTablesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListTables with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListTables(listTablesOptions *ListTablesOptions)`, func() {
		listTablesPath := "/catalogs/testString/schemas/testString/tables"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTablesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"tables": ["Tables"]}`)
				}))
			})
			It(`Invoke ListTables successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListTablesWithContext(ctx, listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListTablesWithContext(ctx, listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTablesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"tables": ["Tables"]}`)
				}))
			})
			It(`Invoke ListTables successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListTables(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListTables with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListTablesOptions model with no property values
				listTablesOptionsModelNew := new(watsonxdatav2.ListTablesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListTables(listTablesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListTables successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTablesOptions model
				listTablesOptionsModel := new(watsonxdatav2.ListTablesOptions)
				listTablesOptionsModel.CatalogID = core.StringPtr("testString")
				listTablesOptionsModel.SchemaID = core.StringPtr("testString")
				listTablesOptionsModel.EngineID = core.StringPtr("testString")
				listTablesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTablesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListTables(listTablesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetTable(getTableOptions *GetTableOptions) - Operation response error`, func() {
		getTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getTablePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetTable with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetTable(getTableOptions *GetTableOptions)`, func() {
		getTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getTablePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}], "table_name": "TableName"}`)
				}))
			})
			It(`Invoke GetTable successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetTableWithContext(ctx, getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetTableWithContext(ctx, getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getTablePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}], "table_name": "TableName"}`)
				}))
			})
			It(`Invoke GetTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetTable(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetTable with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetTableOptions model with no property values
				getTableOptionsModelNew := new(watsonxdatav2.GetTableOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetTable(getTableOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetTableOptions model
				getTableOptionsModel := new(watsonxdatav2.GetTableOptions)
				getTableOptionsModel.CatalogID = core.StringPtr("testString")
				getTableOptionsModel.SchemaID = core.StringPtr("testString")
				getTableOptionsModel.TableID = core.StringPtr("testString")
				getTableOptionsModel.EngineID = core.StringPtr("testString")
				getTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetTable(getTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteTable(deleteTableOptions *DeleteTableOptions)`, func() {
		deleteTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteTablePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteTable(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteTableOptions model
				deleteTableOptionsModel := new(watsonxdatav2.DeleteTableOptions)
				deleteTableOptionsModel.CatalogID = core.StringPtr("testString")
				deleteTableOptionsModel.SchemaID = core.StringPtr("testString")
				deleteTableOptionsModel.TableID = core.StringPtr("testString")
				deleteTableOptionsModel.EngineID = core.StringPtr("testString")
				deleteTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteTable(deleteTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteTable with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteTableOptions model
				deleteTableOptionsModel := new(watsonxdatav2.DeleteTableOptions)
				deleteTableOptionsModel.CatalogID = core.StringPtr("testString")
				deleteTableOptionsModel.SchemaID = core.StringPtr("testString")
				deleteTableOptionsModel.TableID = core.StringPtr("testString")
				deleteTableOptionsModel.EngineID = core.StringPtr("testString")
				deleteTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteTable(deleteTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteTableOptions model with no property values
				deleteTableOptionsModelNew := new(watsonxdatav2.DeleteTableOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteTable(deleteTableOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RenameTable(renameTableOptions *RenameTableOptions) - Operation response error`, func() {
		renameTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(renameTablePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RenameTable with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the RenameTableOptions model
				renameTableOptionsModel := new(watsonxdatav2.RenameTableOptions)
				renameTableOptionsModel.CatalogID = core.StringPtr("testString")
				renameTableOptionsModel.SchemaID = core.StringPtr("testString")
				renameTableOptionsModel.TableID = core.StringPtr("testString")
				renameTableOptionsModel.EngineID = core.StringPtr("testString")
				renameTableOptionsModel.Body = tablePatchModelAsPatch
				renameTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				renameTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RenameTable(renameTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RenameTable(renameTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RenameTable(renameTableOptions *RenameTableOptions)`, func() {
		renameTablePath := "/catalogs/testString/schemas/testString/tables/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(renameTablePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}], "table_name": "TableName"}`)
				}))
			})
			It(`Invoke RenameTable successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the RenameTableOptions model
				renameTableOptionsModel := new(watsonxdatav2.RenameTableOptions)
				renameTableOptionsModel.CatalogID = core.StringPtr("testString")
				renameTableOptionsModel.SchemaID = core.StringPtr("testString")
				renameTableOptionsModel.TableID = core.StringPtr("testString")
				renameTableOptionsModel.EngineID = core.StringPtr("testString")
				renameTableOptionsModel.Body = tablePatchModelAsPatch
				renameTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				renameTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RenameTableWithContext(ctx, renameTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RenameTable(renameTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RenameTableWithContext(ctx, renameTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(renameTablePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}], "table_name": "TableName"}`)
				}))
			})
			It(`Invoke RenameTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RenameTable(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the RenameTableOptions model
				renameTableOptionsModel := new(watsonxdatav2.RenameTableOptions)
				renameTableOptionsModel.CatalogID = core.StringPtr("testString")
				renameTableOptionsModel.SchemaID = core.StringPtr("testString")
				renameTableOptionsModel.TableID = core.StringPtr("testString")
				renameTableOptionsModel.EngineID = core.StringPtr("testString")
				renameTableOptionsModel.Body = tablePatchModelAsPatch
				renameTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				renameTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RenameTable(renameTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RenameTable with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the RenameTableOptions model
				renameTableOptionsModel := new(watsonxdatav2.RenameTableOptions)
				renameTableOptionsModel.CatalogID = core.StringPtr("testString")
				renameTableOptionsModel.SchemaID = core.StringPtr("testString")
				renameTableOptionsModel.TableID = core.StringPtr("testString")
				renameTableOptionsModel.EngineID = core.StringPtr("testString")
				renameTableOptionsModel.Body = tablePatchModelAsPatch
				renameTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				renameTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RenameTable(renameTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RenameTableOptions model with no property values
				renameTableOptionsModelNew := new(watsonxdatav2.RenameTableOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RenameTable(renameTableOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke RenameTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the TablePatch model
				tablePatchModel := new(watsonxdatav2.TablePatch)
				tablePatchModel.TableName = core.StringPtr("updated_table_name")
				tablePatchModelAsPatch, asPatchErr := tablePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the RenameTableOptions model
				renameTableOptionsModel := new(watsonxdatav2.RenameTableOptions)
				renameTableOptionsModel.CatalogID = core.StringPtr("testString")
				renameTableOptionsModel.SchemaID = core.StringPtr("testString")
				renameTableOptionsModel.TableID = core.StringPtr("testString")
				renameTableOptionsModel.EngineID = core.StringPtr("testString")
				renameTableOptionsModel.Body = tablePatchModelAsPatch
				renameTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				renameTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RenameTable(renameTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListColumns(listColumnsOptions *ListColumnsOptions) - Operation response error`, func() {
		listColumnsPath := "/catalogs/testString/schemas/testString/tables/testString/columns"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listColumnsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListColumns with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListColumns(listColumnsOptions *ListColumnsOptions)`, func() {
		listColumnsPath := "/catalogs/testString/schemas/testString/tables/testString/columns"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listColumnsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}]}`)
				}))
			})
			It(`Invoke ListColumns successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListColumnsWithContext(ctx, listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListColumnsWithContext(ctx, listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listColumnsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}]}`)
				}))
			})
			It(`Invoke ListColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListColumns(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListColumns with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListColumnsOptions model with no property values
				listColumnsOptionsModelNew := new(watsonxdatav2.ListColumnsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListColumns(listColumnsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListColumnsOptions model
				listColumnsOptionsModel := new(watsonxdatav2.ListColumnsOptions)
				listColumnsOptionsModel.EngineID = core.StringPtr("testString")
				listColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				listColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				listColumnsOptionsModel.TableID = core.StringPtr("testString")
				listColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListColumns(listColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateColumns(createColumnsOptions *CreateColumnsOptions) - Operation response error`, func() {
		createColumnsPath := "/catalogs/testString/schemas/testString/tables/testString/columns"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createColumnsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateColumns with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateColumns(createColumnsOptions *CreateColumnsOptions)`, func() {
		createColumnsPath := "/catalogs/testString/schemas/testString/tables/testString/columns"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createColumnsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}]}`)
				}))
			})
			It(`Invoke CreateColumns successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateColumnsWithContext(ctx, createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateColumnsWithContext(ctx, createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createColumnsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"columns": [{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}]}`)
				}))
			})
			It(`Invoke CreateColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateColumns(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateColumns with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateColumnsOptions model with no property values
				createColumnsOptionsModelNew := new(watsonxdatav2.CreateColumnsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateColumns(createColumnsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateColumns successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Type = core.StringPtr("varchar")

				// Construct an instance of the CreateColumnsOptions model
				createColumnsOptionsModel := new(watsonxdatav2.CreateColumnsOptions)
				createColumnsOptionsModel.EngineID = core.StringPtr("testString")
				createColumnsOptionsModel.CatalogID = core.StringPtr("testString")
				createColumnsOptionsModel.SchemaID = core.StringPtr("testString")
				createColumnsOptionsModel.TableID = core.StringPtr("testString")
				createColumnsOptionsModel.Columns = []watsonxdatav2.Column{*columnModel}
				createColumnsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createColumnsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateColumns(createColumnsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteColumn(deleteColumnOptions *DeleteColumnOptions)`, func() {
		deleteColumnPath := "/catalogs/testString/schemas/testString/tables/testString/columns/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteColumnPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteColumn successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteColumn(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteColumnOptions model
				deleteColumnOptionsModel := new(watsonxdatav2.DeleteColumnOptions)
				deleteColumnOptionsModel.EngineID = core.StringPtr("testString")
				deleteColumnOptionsModel.CatalogID = core.StringPtr("testString")
				deleteColumnOptionsModel.SchemaID = core.StringPtr("testString")
				deleteColumnOptionsModel.TableID = core.StringPtr("testString")
				deleteColumnOptionsModel.ColumnID = core.StringPtr("testString")
				deleteColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteColumn(deleteColumnOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteColumn with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteColumnOptions model
				deleteColumnOptionsModel := new(watsonxdatav2.DeleteColumnOptions)
				deleteColumnOptionsModel.EngineID = core.StringPtr("testString")
				deleteColumnOptionsModel.CatalogID = core.StringPtr("testString")
				deleteColumnOptionsModel.SchemaID = core.StringPtr("testString")
				deleteColumnOptionsModel.TableID = core.StringPtr("testString")
				deleteColumnOptionsModel.ColumnID = core.StringPtr("testString")
				deleteColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteColumn(deleteColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteColumnOptions model with no property values
				deleteColumnOptionsModelNew := new(watsonxdatav2.DeleteColumnOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteColumn(deleteColumnOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateColumn(updateColumnOptions *UpdateColumnOptions) - Operation response error`, func() {
		updateColumnPath := "/catalogs/testString/schemas/testString/tables/testString/columns/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateColumnPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateColumn with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateColumn(updateColumnOptions *UpdateColumnOptions)`, func() {
		updateColumnPath := "/catalogs/testString/schemas/testString/tables/testString/columns/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateColumnPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}`)
				}))
			})
			It(`Invoke UpdateColumn successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateColumnWithContext(ctx, updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateColumnWithContext(ctx, updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateColumnPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"column_name": "expenses", "comment": "expenses column", "extra": "varchar", "length": "30", "scale": "2", "type": "varchar"}`)
				}))
			})
			It(`Invoke UpdateColumn successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateColumn(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateColumn with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateColumnOptions model with no property values
				updateColumnOptionsModelNew := new(watsonxdatav2.UpdateColumnOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateColumn(updateColumnOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateColumn successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ColumnPatch model
				columnPatchModel := new(watsonxdatav2.ColumnPatch)
				columnPatchModel.ColumnName = core.StringPtr("expenses")
				columnPatchModelAsPatch, asPatchErr := columnPatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateColumnOptions model
				updateColumnOptionsModel := new(watsonxdatav2.UpdateColumnOptions)
				updateColumnOptionsModel.EngineID = core.StringPtr("testString")
				updateColumnOptionsModel.CatalogID = core.StringPtr("testString")
				updateColumnOptionsModel.SchemaID = core.StringPtr("testString")
				updateColumnOptionsModel.TableID = core.StringPtr("testString")
				updateColumnOptionsModel.ColumnID = core.StringPtr("testString")
				updateColumnOptionsModel.Body = columnPatchModelAsPatch
				updateColumnOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateColumnOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateColumn(updateColumnOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListTableSnapshots(listTableSnapshotsOptions *ListTableSnapshotsOptions) - Operation response error`, func() {
		listTableSnapshotsPath := "/catalogs/testString/schemas/testString/tables/testString/snapshots"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTableSnapshotsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListTableSnapshots with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListTableSnapshots(listTableSnapshotsOptions *ListTableSnapshotsOptions)`, func() {
		listTableSnapshotsPath := "/catalogs/testString/schemas/testString/tables/testString/snapshots"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTableSnapshotsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"snapshots": [{"committed_at": "1609379392", "operation": "alter", "snapshot_id": "2332342122211222", "summary": "Summary"}]}`)
				}))
			})
			It(`Invoke ListTableSnapshots successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListTableSnapshotsWithContext(ctx, listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListTableSnapshotsWithContext(ctx, listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listTableSnapshotsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"snapshots": [{"committed_at": "1609379392", "operation": "alter", "snapshot_id": "2332342122211222", "summary": "Summary"}]}`)
				}))
			})
			It(`Invoke ListTableSnapshots successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListTableSnapshots(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListTableSnapshots with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListTableSnapshotsOptions model with no property values
				listTableSnapshotsOptionsModelNew := new(watsonxdatav2.ListTableSnapshotsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListTableSnapshots successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListTableSnapshotsOptions model
				listTableSnapshotsOptionsModel := new(watsonxdatav2.ListTableSnapshotsOptions)
				listTableSnapshotsOptionsModel.EngineID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.CatalogID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.SchemaID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.TableID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listTableSnapshotsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListTableSnapshots(listTableSnapshotsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RollbackTable(rollbackTableOptions *RollbackTableOptions) - Operation response error`, func() {
		rollbackTablePath := "/catalogs/testString/schemas/testString/tables/testString/rollback"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(rollbackTablePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke RollbackTable with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`RollbackTable(rollbackTableOptions *RollbackTableOptions)`, func() {
		rollbackTablePath := "/catalogs/testString/schemas/testString/tables/testString/rollback"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(rollbackTablePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke RollbackTable successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.RollbackTableWithContext(ctx, rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.RollbackTableWithContext(ctx, rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(rollbackTablePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["engine_id"]).To(Equal([]string{"testString"}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke RollbackTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.RollbackTable(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke RollbackTable with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the RollbackTableOptions model with no property values
				rollbackTableOptionsModelNew := new(watsonxdatav2.RollbackTableOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.RollbackTable(rollbackTableOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke RollbackTable successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the RollbackTableOptions model
				rollbackTableOptionsModel := new(watsonxdatav2.RollbackTableOptions)
				rollbackTableOptionsModel.EngineID = core.StringPtr("testString")
				rollbackTableOptionsModel.CatalogID = core.StringPtr("testString")
				rollbackTableOptionsModel.SchemaID = core.StringPtr("testString")
				rollbackTableOptionsModel.TableID = core.StringPtr("testString")
				rollbackTableOptionsModel.SnapshotID = core.StringPtr("testString")
				rollbackTableOptionsModel.AuthInstanceID = core.StringPtr("testString")
				rollbackTableOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.RollbackTable(rollbackTableOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSyncCatalog(updateSyncCatalogOptions *UpdateSyncCatalogOptions) - Operation response error`, func() {
		updateSyncCatalogPath := "/catalogs/testString/sync"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSyncCatalogPath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateSyncCatalog with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateSyncCatalog(updateSyncCatalogOptions *UpdateSyncCatalogOptions)`, func() {
		updateSyncCatalogPath := "/catalogs/testString/sync"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSyncCatalogPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke UpdateSyncCatalog successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateSyncCatalogWithContext(ctx, updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateSyncCatalogWithContext(ctx, updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateSyncCatalogPath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"response": {"message": "Message", "message_code": "MessageCode"}}`)
				}))
			})
			It(`Invoke UpdateSyncCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateSyncCatalog with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateSyncCatalogOptions model with no property values
				updateSyncCatalogOptionsModelNew := new(watsonxdatav2.UpdateSyncCatalogOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateSyncCatalog successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the SyncCatalogs model
				syncCatalogsModel := new(watsonxdatav2.SyncCatalogs)
				syncCatalogsModel.AutoAddNewTables = core.BoolPtr(true)
				syncCatalogsModel.SyncIcebergMd = core.BoolPtr(true)
				syncCatalogsModelAsPatch, asPatchErr := syncCatalogsModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateSyncCatalogOptions model
				updateSyncCatalogOptionsModel := new(watsonxdatav2.UpdateSyncCatalogOptions)
				updateSyncCatalogOptionsModel.CatalogID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Body = syncCatalogsModelAsPatch
				updateSyncCatalogOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateSyncCatalogOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateSyncCatalog(updateSyncCatalogOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListMilvusServices(listMilvusServicesOptions *ListMilvusServicesOptions) - Operation response error`, func() {
		listMilvusServicesPath := "/milvus_services"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusServicesPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListMilvusServices with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListMilvusServices(listMilvusServicesOptions *ListMilvusServicesOptions)`, func() {
		listMilvusServicesPath := "/milvus_services"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusServicesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"milvus_services": [{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "milvus"}]}`)
				}))
			})
			It(`Invoke ListMilvusServices successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListMilvusServicesWithContext(ctx, listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListMilvusServicesWithContext(ctx, listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listMilvusServicesPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"milvus_services": [{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "milvus"}]}`)
				}))
			})
			It(`Invoke ListMilvusServices successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListMilvusServices(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListMilvusServices with error: Operation request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListMilvusServices successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := new(watsonxdatav2.ListMilvusServicesOptions)
				listMilvusServicesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listMilvusServicesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListMilvusServices(listMilvusServicesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusService(createMilvusServiceOptions *CreateMilvusServiceOptions) - Operation response error`, func() {
		createMilvusServicePath := "/milvus_services"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServicePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateMilvusService with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateMilvusService(createMilvusServiceOptions *CreateMilvusServiceOptions)`, func() {
		createMilvusServicePath := "/milvus_services"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServicePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "milvus"}`)
				}))
			})
			It(`Invoke CreateMilvusService successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateMilvusServiceWithContext(ctx, createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateMilvusServiceWithContext(ctx, createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createMilvusServicePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "milvus"}`)
				}))
			})
			It(`Invoke CreateMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateMilvusService(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateMilvusService with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateMilvusServiceOptions model with no property values
				createMilvusServiceOptionsModelNew := new(watsonxdatav2.CreateMilvusServiceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreateMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsModel := new(watsonxdatav2.CreateMilvusServiceOptions)
				createMilvusServiceOptionsModel.Origin = core.StringPtr("native")
				createMilvusServiceOptionsModel.Description = core.StringPtr("milvus service for running sql queries")
				createMilvusServiceOptionsModel.ServiceDisplayName = core.StringPtr("sampleService")
				createMilvusServiceOptionsModel.Tags = []string{"tag1", "tag2"}
				createMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateMilvusService(createMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetMilvusService(getMilvusServiceOptions *GetMilvusServiceOptions) - Operation response error`, func() {
		getMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getMilvusServicePath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetMilvusService with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetMilvusService(getMilvusServiceOptions *GetMilvusServiceOptions)`, func() {
		getMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getMilvusServicePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "milvus"}`)
				}))
			})
			It(`Invoke GetMilvusService successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetMilvusServiceWithContext(ctx, getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetMilvusServiceWithContext(ctx, getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getMilvusServicePath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "milvus"}`)
				}))
			})
			It(`Invoke GetMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetMilvusService(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetMilvusService with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetMilvusServiceOptions model with no property values
				getMilvusServiceOptionsModelNew := new(watsonxdatav2.GetMilvusServiceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetMilvusService(getMilvusServiceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetMilvusServiceOptions model
				getMilvusServiceOptionsModel := new(watsonxdatav2.GetMilvusServiceOptions)
				getMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetMilvusService(getMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteMilvusService(deleteMilvusServiceOptions *DeleteMilvusServiceOptions)`, func() {
		deleteMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteMilvusServicePath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteMilvusService(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteMilvusServiceOptions model
				deleteMilvusServiceOptionsModel := new(watsonxdatav2.DeleteMilvusServiceOptions)
				deleteMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				deleteMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteMilvusService(deleteMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteMilvusService with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteMilvusServiceOptions model
				deleteMilvusServiceOptionsModel := new(watsonxdatav2.DeleteMilvusServiceOptions)
				deleteMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				deleteMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteMilvusService(deleteMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteMilvusServiceOptions model with no property values
				deleteMilvusServiceOptionsModelNew := new(watsonxdatav2.DeleteMilvusServiceOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteMilvusService(deleteMilvusServiceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateMilvusService(updateMilvusServiceOptions *UpdateMilvusServiceOptions) - Operation response error`, func() {
		updateMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateMilvusServicePath))
					Expect(req.Method).To(Equal("PATCH"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke UpdateMilvusService with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`UpdateMilvusService(updateMilvusServiceOptions *UpdateMilvusServiceOptions)`, func() {
		updateMilvusServicePath := "/milvus_services/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateMilvusServicePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "milvus"}`)
				}))
			})
			It(`Invoke UpdateMilvusService successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.UpdateMilvusServiceWithContext(ctx, updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.UpdateMilvusServiceWithContext(ctx, updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(updateMilvusServicePath))
					Expect(req.Method).To(Equal("PATCH"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"actions": ["Actions"], "created_by": "<username>@<domain>.com", "created_on": 9, "description": "milvus service for running sql queries", "grpc_host": "example.grpc.host", "grpc_port": 8, "host_name": "sampleMilvus", "https_host": "example.https.host", "https_port": 9, "origin": "native", "service_display_name": "sampleService", "service_id": "sampleService123", "status": "running", "status_code": 10, "tags": ["Tags"], "type": "milvus"}`)
				}))
			})
			It(`Invoke UpdateMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.UpdateMilvusService(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke UpdateMilvusService with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the UpdateMilvusServiceOptions model with no property values
				updateMilvusServiceOptionsModelNew := new(watsonxdatav2.UpdateMilvusServiceOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke UpdateMilvusService successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the MilvusServicePatch model
				milvusServicePatchModel := new(watsonxdatav2.MilvusServicePatch)
				milvusServicePatchModel.Description = core.StringPtr("updated description for milvus service")
				milvusServicePatchModel.ServiceDisplayName = core.StringPtr("sampleService")
				milvusServicePatchModel.Tags = []string{"tag1", "tag2"}
				milvusServicePatchModelAsPatch, asPatchErr := milvusServicePatchModel.AsPatch()
				Expect(asPatchErr).To(BeNil())

				// Construct an instance of the UpdateMilvusServiceOptions model
				updateMilvusServiceOptionsModel := new(watsonxdatav2.UpdateMilvusServiceOptions)
				updateMilvusServiceOptionsModel.ServiceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Body = milvusServicePatchModelAsPatch
				updateMilvusServiceOptionsModel.AuthInstanceID = core.StringPtr("testString")
				updateMilvusServiceOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.UpdateMilvusService(updateMilvusServiceOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListIngestionJobs(listIngestionJobsOptions *ListIngestionJobsOptions) - Operation response error`, func() {
		listIngestionJobsPath := "/ingestion_jobs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listIngestionJobsPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["page"]).To(Equal([]string{fmt.Sprint(int64(1))}))
					Expect(req.URL.Query()["jobs_per_page"]).To(Equal([]string{fmt.Sprint(int64(1))}))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke ListIngestionJobs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Page = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`ListIngestionJobs(listIngestionJobsOptions *ListIngestionJobsOptions)`, func() {
		listIngestionJobsPath := "/ingestion_jobs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listIngestionJobsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["page"]).To(Equal([]string{fmt.Sprint(int64(1))}))
					Expect(req.URL.Query()["jobs_per_page"]).To(Equal([]string{fmt.Sprint(int64(1))}))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ingestion_jobs": [{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}], "first": {"href": "http://api.example.com/collection?start=eyJvZmZzZXQiOjAsImRvbmUiOnRydWV9"}, "next": {"href": "http://api.example.com/collection?start=eyJvZmZzZXQiOjAsImRvbmUiOnRydWV9"}}`)
				}))
			})
			It(`Invoke ListIngestionJobs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Page = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.ListIngestionJobsWithContext(ctx, listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.ListIngestionJobsWithContext(ctx, listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(listIngestionJobsPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					Expect(req.URL.Query()["page"]).To(Equal([]string{fmt.Sprint(int64(1))}))
					Expect(req.URL.Query()["jobs_per_page"]).To(Equal([]string{fmt.Sprint(int64(1))}))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"ingestion_jobs": [{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}], "first": {"href": "http://api.example.com/collection?start=eyJvZmZzZXQiOjAsImRvbmUiOnRydWV9"}, "next": {"href": "http://api.example.com/collection?start=eyJvZmZzZXQiOjAsImRvbmUiOnRydWV9"}}`)
				}))
			})
			It(`Invoke ListIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.ListIngestionJobs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Page = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke ListIngestionJobs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Page = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the ListIngestionJobsOptions model with no property values
				listIngestionJobsOptionsModelNew := new(watsonxdatav2.ListIngestionJobsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke ListIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the ListIngestionJobsOptions model
				listIngestionJobsOptionsModel := new(watsonxdatav2.ListIngestionJobsOptions)
				listIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				listIngestionJobsOptionsModel.Page = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.JobsPerPage = core.Int64Ptr(int64(1))
				listIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.ListIngestionJobs(listIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateIngestionJobs(createIngestionJobsOptions *CreateIngestionJobsOptions) - Operation response error`, func() {
		createIngestionJobsPath := "/ingestion_jobs"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateIngestionJobs with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateIngestionJobs(createIngestionJobsOptions *CreateIngestionJobsOptions)`, func() {
		createIngestionJobsPath := "/ingestion_jobs"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke CreateIngestionJobs successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateIngestionJobsWithContext(ctx, createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateIngestionJobsWithContext(ctx, createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsPath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke CreateIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateIngestionJobs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateIngestionJobsOptions model with no property values
				createIngestionJobsOptionsModelNew := new(watsonxdatav2.CreateIngestionJobsOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke CreateIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))

				// Construct an instance of the CreateIngestionJobsOptions model
				createIngestionJobsOptionsModel := new(watsonxdatav2.CreateIngestionJobsOptions)
				createIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsOptionsModel.JobID = core.StringPtr("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.TargetTable = core.StringPtr("demodb.test.targettable")
				createIngestionJobsOptionsModel.Username = core.StringPtr("user1")
				createIngestionJobsOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsOptionsModel.CsvProperty = ingestionJobPrototypeCsvPropertyModel
				createIngestionJobsOptionsModel.EngineID = core.StringPtr("spark123")
				createIngestionJobsOptionsModel.ExecuteConfig = ingestionJobPrototypeExecuteConfigModel
				createIngestionJobsOptionsModel.PartitionBy = core.StringPtr("col1, col2")
				createIngestionJobsOptionsModel.Schema = core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateIngestionJobs(createIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptions *CreateIngestionJobsLocalFilesOptions) - Operation response error`, func() {
		createIngestionJobsLocalFilesPath := "/ingestion_jobs_local_files"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsLocalFilesPath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreateIngestionJobsLocalFiles with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptions *CreateIngestionJobsLocalFilesOptions)`, func() {
		createIngestionJobsLocalFilesPath := "/ingestion_jobs_local_files"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsLocalFilesPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke CreateIngestionJobsLocalFiles successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreateIngestionJobsLocalFilesWithContext(ctx, createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreateIngestionJobsLocalFilesWithContext(ctx, createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createIngestionJobsLocalFilesPath))
					Expect(req.Method).To(Equal("POST"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(202)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke CreateIngestionJobsLocalFiles successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreateIngestionJobsLocalFiles with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreateIngestionJobsLocalFilesOptions model with no property values
				createIngestionJobsLocalFilesOptionsModelNew := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(202)
				}))
			})
			It(`Invoke CreateIngestionJobsLocalFiles successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				createIngestionJobsLocalFilesOptionsModel := new(watsonxdatav2.CreateIngestionJobsLocalFilesOptions)
				createIngestionJobsLocalFilesOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFile = CreateMockReader("This is a mock file.")
				createIngestionJobsLocalFilesOptionsModel.TargetTable = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.JobID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Username = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.SourceFileType = core.StringPtr("csv")
				createIngestionJobsLocalFilesOptionsModel.CsvProperty = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader = core.BoolPtr(false)
				createIngestionJobsLocalFilesOptionsModel.ExecuteConfig = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.EngineID = core.StringPtr("testString")
				createIngestionJobsLocalFilesOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreateIngestionJobsLocalFiles(createIngestionJobsLocalFilesOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetIngestionJob(getIngestionJobOptions *GetIngestionJobOptions) - Operation response error`, func() {
		getIngestionJobPath := "/ingestion_jobs/testString"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIngestionJobPath))
					Expect(req.Method).To(Equal("GET"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke GetIngestionJob with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`GetIngestionJob(getIngestionJobOptions *GetIngestionJobOptions)`, func() {
		getIngestionJobPath := "/ingestion_jobs/testString"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIngestionJobPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke GetIngestionJob successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.GetIngestionJobWithContext(ctx, getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.GetIngestionJobWithContext(ctx, getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(getIngestionJobPath))
					Expect(req.Method).To(Equal("GET"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(200)
					fmt.Fprintf(res, "%s", `{"create_if_not_exist": false, "csv_property": {"encoding": "utf-8", "escape_character": "|", "field_delimiter": ",", "header": true, "line_delimiter": "\n"}, "details": "Path does not exist 'demobucket/data/yellow_tripdata_2022-01.parquet'. Detail: [errno 2] No such file or directory", "end_timestamp": "1685088775", "engine_id": "spark123", "engine_name": "sparkdemo", "execute_config": {"driver_cores": 1, "driver_memory": "2G", "executor_cores": 1, "executor_memory": "2G", "num_executors": 1}, "instance_id": "1684432229673971", "job_id": "ingestion-1699459946935", "partition_by": "col1, col2", "schema": "{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}", "source_data_files": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "source_file_type": "csv", "start_timestamp": "1685084455", "status": "running", "target_table": "demodb.test.targettable", "username": "ibmlhadmin", "validate_csv_header": false}`)
				}))
			})
			It(`Invoke GetIngestionJob successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.GetIngestionJob(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke GetIngestionJob with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the GetIngestionJobOptions model with no property values
				getIngestionJobOptionsModelNew := new(watsonxdatav2.GetIngestionJobOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.GetIngestionJob(getIngestionJobOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(200)
				}))
			})
			It(`Invoke GetIngestionJob successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the GetIngestionJobOptions model
				getIngestionJobOptionsModel := new(watsonxdatav2.GetIngestionJobOptions)
				getIngestionJobOptionsModel.JobID = core.StringPtr("testString")
				getIngestionJobOptionsModel.AuthInstanceID = core.StringPtr("testString")
				getIngestionJobOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.GetIngestionJob(getIngestionJobOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`DeleteIngestionJobs(deleteIngestionJobsOptions *DeleteIngestionJobsOptions)`, func() {
		deleteIngestionJobsPath := "/ingestion_jobs/testString"
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(deleteIngestionJobsPath))
					Expect(req.Method).To(Equal("DELETE"))

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.WriteHeader(204)
				}))
			})
			It(`Invoke DeleteIngestionJobs successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				response, operationErr := watsonxDataService.DeleteIngestionJobs(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())

				// Construct an instance of the DeleteIngestionJobsOptions model
				deleteIngestionJobsOptionsModel := new(watsonxdatav2.DeleteIngestionJobsOptions)
				deleteIngestionJobsOptionsModel.JobID = core.StringPtr("testString")
				deleteIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				response, operationErr = watsonxDataService.DeleteIngestionJobs(deleteIngestionJobsOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
			})
			It(`Invoke DeleteIngestionJobs with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the DeleteIngestionJobsOptions model
				deleteIngestionJobsOptionsModel := new(watsonxdatav2.DeleteIngestionJobsOptions)
				deleteIngestionJobsOptionsModel.JobID = core.StringPtr("testString")
				deleteIngestionJobsOptionsModel.AuthInstanceID = core.StringPtr("testString")
				deleteIngestionJobsOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				response, operationErr := watsonxDataService.DeleteIngestionJobs(deleteIngestionJobsOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				// Construct a second instance of the DeleteIngestionJobsOptions model with no property values
				deleteIngestionJobsOptionsModelNew := new(watsonxdatav2.DeleteIngestionJobsOptions)
				// Invoke operation with invalid model (negative test)
				response, operationErr = watsonxDataService.DeleteIngestionJobs(deleteIngestionJobsOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePreviewIngestionFile(createPreviewIngestionFileOptions *CreatePreviewIngestionFileOptions) - Operation response error`, func() {
		createPreviewIngestionFilePath := "/preview_ingestion_file"
		Context(`Using mock server endpoint with invalid JSON response`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPreviewIngestionFilePath))
					Expect(req.Method).To(Equal("POST"))
					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprint(res, `} this is not valid json {`)
				}))
			})
			It(`Invoke CreatePreviewIngestionFile with error: Operation response processing error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Expect response parsing to fail since we are receiving a text/plain response
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())

				// Enable retries and test again
				watsonxDataService.EnableRetries(0, 0)
				result, response, operationErr = watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`CreatePreviewIngestionFile(createPreviewIngestionFileOptions *CreatePreviewIngestionFileOptions)`, func() {
		createPreviewIngestionFilePath := "/preview_ingestion_file"
		Context(`Using mock server endpoint with timeout`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPreviewIngestionFilePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Sleep a short time to support a timeout test
					time.Sleep(100 * time.Millisecond)

					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"column_names": ["col1"], "column_types": ["int"], "file_name": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "rows": {"row_eight": ["Jane Doe"], "row_five": ["Jane Doe"], "row_four": ["Jane Doe"], "row_nine": ["Jane Doe"], "row_one": ["Jane Doe"], "row_seven": ["Jane Doe"], "row_six": ["Jane Doe"], "row_ten": ["Jane Doe"], "row_three": ["Jane Doe"], "row_two": ["Jane Doe"]}}`)
				}))
			})
			It(`Invoke CreatePreviewIngestionFile successfully with retries`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())
				watsonxDataService.EnableRetries(0, 0)

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with a Context to test a timeout error
				ctx, cancelFunc := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc()
				_, _, operationErr := watsonxDataService.CreatePreviewIngestionFileWithContext(ctx, createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))

				// Disable retries and test again
				watsonxDataService.DisableRetries()
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

				// Re-test the timeout error with retries disabled
				ctx, cancelFunc2 := context.WithTimeout(context.Background(), 80*time.Millisecond)
				defer cancelFunc2()
				_, _, operationErr = watsonxDataService.CreatePreviewIngestionFileWithContext(ctx, createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring("deadline exceeded"))
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Verify the contents of the request
					Expect(req.URL.EscapedPath()).To(Equal(createPreviewIngestionFilePath))
					Expect(req.Method).To(Equal("POST"))

					// For gzip-disabled operation, verify Content-Encoding is not set.
					Expect(req.Header.Get("Content-Encoding")).To(BeEmpty())

					// If there is a body, then make sure we can read it
					bodyBuf := new(bytes.Buffer)
					if req.Header.Get("Content-Encoding") == "gzip" {
						body, err := core.NewGzipDecompressionReader(req.Body)
						Expect(err).To(BeNil())
						_, err = bodyBuf.ReadFrom(body)
						Expect(err).To(BeNil())
					} else {
						_, err := bodyBuf.ReadFrom(req.Body)
						Expect(err).To(BeNil())
					}
					fmt.Fprintf(GinkgoWriter, "  Request body: %s", bodyBuf.String())

					Expect(req.Header["Authinstanceid"]).ToNot(BeNil())
					Expect(req.Header["Authinstanceid"][0]).To(Equal(fmt.Sprintf("%v", "testString")))
					// Set mock response
					res.Header().Set("Content-type", "application/json")
					res.WriteHeader(201)
					fmt.Fprintf(res, "%s", `{"column_names": ["col1"], "column_types": ["int"], "file_name": "s3://demobucket/data/yellow_tripdata_2022-01.parquet", "rows": {"row_eight": ["Jane Doe"], "row_five": ["Jane Doe"], "row_four": ["Jane Doe"], "row_nine": ["Jane Doe"], "row_one": ["Jane Doe"], "row_seven": ["Jane Doe"], "row_six": ["Jane Doe"], "row_ten": ["Jane Doe"], "row_three": ["Jane Doe"], "row_two": ["Jane Doe"]}}`)
				}))
			})
			It(`Invoke CreatePreviewIngestionFile successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Invoke operation with nil options model (negative test)
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(nil)
				Expect(operationErr).NotTo(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation with valid options model (positive test)
				result, response, operationErr = watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())
				Expect(result).ToNot(BeNil())

			})
			It(`Invoke CreatePreviewIngestionFile with error: Operation validation and request error`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}
				// Invoke operation with empty URL (negative test)
				err := watsonxDataService.SetServiceURL("")
				Expect(err).To(BeNil())
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).ToNot(BeNil())
				Expect(operationErr.Error()).To(ContainSubstring(core.ERRORMSG_SERVICE_URL_MISSING))
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
				// Construct a second instance of the CreatePreviewIngestionFileOptions model with no property values
				createPreviewIngestionFileOptionsModelNew := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				// Invoke operation with invalid model (negative test)
				result, response, operationErr = watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModelNew)
				Expect(operationErr).ToNot(BeNil())
				Expect(response).To(BeNil())
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
		Context(`Using mock server endpoint with missing response body`, func() {
			BeforeEach(func() {
				testServer = httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
					defer GinkgoRecover()

					// Set success status code with no respoonse body
					res.WriteHeader(201)
				}))
			})
			It(`Invoke CreatePreviewIngestionFile successfully`, func() {
				watsonxDataService, serviceErr := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
					URL:           testServer.URL,
					Authenticator: &core.NoAuthAuthenticator{},
				})
				Expect(serviceErr).To(BeNil())
				Expect(watsonxDataService).ToNot(BeNil())

				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				createPreviewIngestionFileOptionsModel := new(watsonxdatav2.CreatePreviewIngestionFileOptions)
				createPreviewIngestionFileOptionsModel.AuthInstanceID = core.StringPtr("testString")
				createPreviewIngestionFileOptionsModel.SourceDataFiles = core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.CsvProperty = previewIngestionFilePrototypeCsvPropertyModel
				createPreviewIngestionFileOptionsModel.SourceFileType = core.StringPtr("csv")
				createPreviewIngestionFileOptionsModel.Headers = map[string]string{"x-custom-header": "x-custom-value"}

				// Invoke operation
				result, response, operationErr := watsonxDataService.CreatePreviewIngestionFile(createPreviewIngestionFileOptionsModel)
				Expect(operationErr).To(BeNil())
				Expect(response).ToNot(BeNil())

				// Verify a nil result
				Expect(result).To(BeNil())
			})
			AfterEach(func() {
				testServer.Close()
			})
		})
	})
	Describe(`Model constructor tests`, func() {
		Context(`Using a service client instance`, func() {
			watsonxDataService, _ := watsonxdatav2.NewWatsonxDataV2(&watsonxdatav2.WatsonxDataV2Options{
				URL:           "http://watsonxdatav2modelgenerator.com",
				Authenticator: &core.NoAuthAuthenticator{},
			})
			It(`Invoke NewAddPrestissimoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the AddPrestissimoEngineCatalogsOptions model
				engineID := "testString"
				addPrestissimoEngineCatalogsOptionsModel := watsonxDataService.NewAddPrestissimoEngineCatalogsOptions(engineID)
				addPrestissimoEngineCatalogsOptionsModel.SetEngineID("testString")
				addPrestissimoEngineCatalogsOptionsModel.SetCatalogNames("testString")
				addPrestissimoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				addPrestissimoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(addPrestissimoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(addPrestissimoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(addPrestissimoEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(addPrestissimoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(addPrestissimoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewAddPrestoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the AddPrestoEngineCatalogsOptions model
				engineID := "testString"
				addPrestoEngineCatalogsOptionsModel := watsonxDataService.NewAddPrestoEngineCatalogsOptions(engineID)
				addPrestoEngineCatalogsOptionsModel.SetEngineID("testString")
				addPrestoEngineCatalogsOptionsModel.SetCatalogNames("testString")
				addPrestoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				addPrestoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(addPrestoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(addPrestoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(addPrestoEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(addPrestoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(addPrestoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewAddSparkEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the AddSparkEngineCatalogsOptions model
				engineID := "testString"
				addSparkEngineCatalogsOptionsModel := watsonxDataService.NewAddSparkEngineCatalogsOptions(engineID)
				addSparkEngineCatalogsOptionsModel.SetEngineID("testString")
				addSparkEngineCatalogsOptionsModel.SetCatalogNames("testString")
				addSparkEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				addSparkEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(addSparkEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(addSparkEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(addSparkEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(addSparkEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(addSparkEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewBucketDetails successfully`, func() {
				bucketName := "sample-bucket"
				_model, err := watsonxDataService.NewBucketDetails(bucketName)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewCreateActivateBucketOptions successfully`, func() {
				// Construct an instance of the CreateActivateBucketOptions model
				bucketID := "testString"
				createActivateBucketOptionsModel := watsonxDataService.NewCreateActivateBucketOptions(bucketID)
				createActivateBucketOptionsModel.SetBucketID("testString")
				createActivateBucketOptionsModel.SetAuthInstanceID("testString")
				createActivateBucketOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createActivateBucketOptionsModel).ToNot(BeNil())
				Expect(createActivateBucketOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(createActivateBucketOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createActivateBucketOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateBucketRegistrationOptions successfully`, func() {
				// Construct an instance of the BucketDetails model
				bucketDetailsModel := new(watsonxdatav2.BucketDetails)
				Expect(bucketDetailsModel).ToNot(BeNil())
				bucketDetailsModel.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
				bucketDetailsModel.BucketName = core.StringPtr("sample-bucket")
				bucketDetailsModel.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
				bucketDetailsModel.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")
				Expect(bucketDetailsModel.AccessKey).To(Equal(core.StringPtr("b9cbf248ea5c4c96947e64407108559j")))
				Expect(bucketDetailsModel.BucketName).To(Equal(core.StringPtr("sample-bucket")))
				Expect(bucketDetailsModel.Endpoint).To(Equal(core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")))
				Expect(bucketDetailsModel.SecretKey).To(Equal(core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")))

				// Construct an instance of the BucketCatalog model
				bucketCatalogModel := new(watsonxdatav2.BucketCatalog)
				Expect(bucketCatalogModel).ToNot(BeNil())
				bucketCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				bucketCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				bucketCatalogModel.CatalogType = core.StringPtr("iceberg")
				Expect(bucketCatalogModel.CatalogName).To(Equal(core.StringPtr("sampleCatalog")))
				Expect(bucketCatalogModel.CatalogTags).To(Equal([]string{"catalog_tag_1", "catalog_tag_2"}))
				Expect(bucketCatalogModel.CatalogType).To(Equal(core.StringPtr("iceberg")))

				// Construct an instance of the CreateBucketRegistrationOptions model
				var createBucketRegistrationOptionsBucketDetails *watsonxdatav2.BucketDetails = nil
				createBucketRegistrationOptionsBucketType := "ibm_cos"
				createBucketRegistrationOptionsDescription := "COS bucket for customer data"
				createBucketRegistrationOptionsManagedBy := "ibm"
				createBucketRegistrationOptionsModel := watsonxDataService.NewCreateBucketRegistrationOptions(createBucketRegistrationOptionsBucketDetails, createBucketRegistrationOptionsBucketType, createBucketRegistrationOptionsDescription, createBucketRegistrationOptionsManagedBy)
				createBucketRegistrationOptionsModel.SetBucketDetails(bucketDetailsModel)
				createBucketRegistrationOptionsModel.SetBucketType("ibm_cos")
				createBucketRegistrationOptionsModel.SetDescription("COS bucket for customer data")
				createBucketRegistrationOptionsModel.SetManagedBy("ibm")
				createBucketRegistrationOptionsModel.SetAssociatedCatalog(bucketCatalogModel)
				createBucketRegistrationOptionsModel.SetBucketDisplayName("sample-bucket-displayname")
				createBucketRegistrationOptionsModel.SetRegion("us-south")
				createBucketRegistrationOptionsModel.SetTags([]string{"bucket-tag1", "bucket-tag2"})
				createBucketRegistrationOptionsModel.SetAuthInstanceID("testString")
				createBucketRegistrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createBucketRegistrationOptionsModel).ToNot(BeNil())
				Expect(createBucketRegistrationOptionsModel.BucketDetails).To(Equal(bucketDetailsModel))
				Expect(createBucketRegistrationOptionsModel.BucketType).To(Equal(core.StringPtr("ibm_cos")))
				Expect(createBucketRegistrationOptionsModel.Description).To(Equal(core.StringPtr("COS bucket for customer data")))
				Expect(createBucketRegistrationOptionsModel.ManagedBy).To(Equal(core.StringPtr("ibm")))
				Expect(createBucketRegistrationOptionsModel.AssociatedCatalog).To(Equal(bucketCatalogModel))
				Expect(createBucketRegistrationOptionsModel.BucketDisplayName).To(Equal(core.StringPtr("sample-bucket-displayname")))
				Expect(createBucketRegistrationOptionsModel.Region).To(Equal(core.StringPtr("us-south")))
				Expect(createBucketRegistrationOptionsModel.Tags).To(Equal([]string{"bucket-tag1", "bucket-tag2"}))
				Expect(createBucketRegistrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createBucketRegistrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateColumnsOptions successfully`, func() {
				// Construct an instance of the Column model
				columnModel := new(watsonxdatav2.Column)
				Expect(columnModel).ToNot(BeNil())
				columnModel.ColumnName = core.StringPtr("expenses")
				columnModel.Comment = core.StringPtr("expenses column")
				columnModel.Extra = core.StringPtr("varchar")
				columnModel.Length = core.StringPtr("30")
				columnModel.Scale = core.StringPtr("2")
				columnModel.Type = core.StringPtr("varchar")
				Expect(columnModel.ColumnName).To(Equal(core.StringPtr("expenses")))
				Expect(columnModel.Comment).To(Equal(core.StringPtr("expenses column")))
				Expect(columnModel.Extra).To(Equal(core.StringPtr("varchar")))
				Expect(columnModel.Length).To(Equal(core.StringPtr("30")))
				Expect(columnModel.Scale).To(Equal(core.StringPtr("2")))
				Expect(columnModel.Type).To(Equal(core.StringPtr("varchar")))

				// Construct an instance of the CreateColumnsOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				createColumnsOptionsModel := watsonxDataService.NewCreateColumnsOptions(engineID, catalogID, schemaID, tableID)
				createColumnsOptionsModel.SetEngineID("testString")
				createColumnsOptionsModel.SetCatalogID("testString")
				createColumnsOptionsModel.SetSchemaID("testString")
				createColumnsOptionsModel.SetTableID("testString")
				createColumnsOptionsModel.SetColumns([]watsonxdatav2.Column{*columnModel})
				createColumnsOptionsModel.SetAuthInstanceID("testString")
				createColumnsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createColumnsOptionsModel).ToNot(BeNil())
				Expect(createColumnsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.Columns).To(Equal([]watsonxdatav2.Column{*columnModel}))
				Expect(createColumnsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createColumnsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateDatabaseRegistrationOptions successfully`, func() {
				// Construct an instance of the DatabaseCatalog model
				databaseCatalogModel := new(watsonxdatav2.DatabaseCatalog)
				Expect(databaseCatalogModel).ToNot(BeNil())
				databaseCatalogModel.CatalogName = core.StringPtr("sampleCatalog")
				databaseCatalogModel.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
				databaseCatalogModel.CatalogType = core.StringPtr("iceberg")
				Expect(databaseCatalogModel.CatalogName).To(Equal(core.StringPtr("sampleCatalog")))
				Expect(databaseCatalogModel.CatalogTags).To(Equal([]string{"catalog_tag_1", "catalog_tag_2"}))
				Expect(databaseCatalogModel.CatalogType).To(Equal(core.StringPtr("iceberg")))

				// Construct an instance of the DatabaseDetails model
				databaseDetailsModel := new(watsonxdatav2.DatabaseDetails)
				Expect(databaseDetailsModel).ToNot(BeNil())
				databaseDetailsModel.Certificate = core.StringPtr("contents of a pem/crt file")
				databaseDetailsModel.CertificateExtension = core.StringPtr("pem/crt")
				databaseDetailsModel.DatabaseName = core.StringPtr("new_database")
				databaseDetailsModel.Hostname = core.StringPtr("db2@<hostname>.com")
				databaseDetailsModel.HostnameInCertificate = core.StringPtr("samplehostname")
				databaseDetailsModel.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
				databaseDetailsModel.Password = core.StringPtr("samplepassword")
				databaseDetailsModel.Port = core.Int64Ptr(int64(4553))
				databaseDetailsModel.Sasl = core.BoolPtr(true)
				databaseDetailsModel.Ssl = core.BoolPtr(true)
				databaseDetailsModel.Tables = core.StringPtr("kafka_table_name")
				databaseDetailsModel.Username = core.StringPtr("sampleuser")
				databaseDetailsModel.ValidateServerCertificate = core.BoolPtr(true)
				Expect(databaseDetailsModel.Certificate).To(Equal(core.StringPtr("contents of a pem/crt file")))
				Expect(databaseDetailsModel.CertificateExtension).To(Equal(core.StringPtr("pem/crt")))
				Expect(databaseDetailsModel.DatabaseName).To(Equal(core.StringPtr("new_database")))
				Expect(databaseDetailsModel.Hostname).To(Equal(core.StringPtr("db2@<hostname>.com")))
				Expect(databaseDetailsModel.HostnameInCertificate).To(Equal(core.StringPtr("samplehostname")))
				Expect(databaseDetailsModel.Hosts).To(Equal(core.StringPtr("abc.com:1234,xyz.com:4321")))
				Expect(databaseDetailsModel.Password).To(Equal(core.StringPtr("samplepassword")))
				Expect(databaseDetailsModel.Port).To(Equal(core.Int64Ptr(int64(4553))))
				Expect(databaseDetailsModel.Sasl).To(Equal(core.BoolPtr(true)))
				Expect(databaseDetailsModel.Ssl).To(Equal(core.BoolPtr(true)))
				Expect(databaseDetailsModel.Tables).To(Equal(core.StringPtr("kafka_table_name")))
				Expect(databaseDetailsModel.Username).To(Equal(core.StringPtr("sampleuser")))
				Expect(databaseDetailsModel.ValidateServerCertificate).To(Equal(core.BoolPtr(true)))

				// Construct an instance of the DatabaseRegistrationPrototypeDatabasePropertiesItems model
				databaseRegistrationPrototypeDatabasePropertiesItemsModel := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
				Expect(databaseRegistrationPrototypeDatabasePropertiesItemsModel).ToNot(BeNil())
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt = core.BoolPtr(true)
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key = core.StringPtr("abc")
				databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value = core.StringPtr("xyz")
				Expect(databaseRegistrationPrototypeDatabasePropertiesItemsModel.Encrypt).To(Equal(core.BoolPtr(true)))
				Expect(databaseRegistrationPrototypeDatabasePropertiesItemsModel.Key).To(Equal(core.StringPtr("abc")))
				Expect(databaseRegistrationPrototypeDatabasePropertiesItemsModel.Value).To(Equal(core.StringPtr("xyz")))

				// Construct an instance of the CreateDatabaseRegistrationOptions model
				createDatabaseRegistrationOptionsDatabaseDisplayName := "new_database"
				createDatabaseRegistrationOptionsDatabaseType := "db2"
				createDatabaseRegistrationOptionsModel := watsonxDataService.NewCreateDatabaseRegistrationOptions(createDatabaseRegistrationOptionsDatabaseDisplayName, createDatabaseRegistrationOptionsDatabaseType)
				createDatabaseRegistrationOptionsModel.SetDatabaseDisplayName("new_database")
				createDatabaseRegistrationOptionsModel.SetDatabaseType("db2")
				createDatabaseRegistrationOptionsModel.SetAssociatedCatalog(databaseCatalogModel)
				createDatabaseRegistrationOptionsModel.SetCreatedOn("1686792721")
				createDatabaseRegistrationOptionsModel.SetDatabaseDetails(databaseDetailsModel)
				createDatabaseRegistrationOptionsModel.SetDatabaseProperties([]watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel})
				createDatabaseRegistrationOptionsModel.SetDescription("db2 extenal database description")
				createDatabaseRegistrationOptionsModel.SetTags([]string{"testdatabase", "userdatabase"})
				createDatabaseRegistrationOptionsModel.SetAuthInstanceID("testString")
				createDatabaseRegistrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createDatabaseRegistrationOptionsModel).ToNot(BeNil())
				Expect(createDatabaseRegistrationOptionsModel.DatabaseDisplayName).To(Equal(core.StringPtr("new_database")))
				Expect(createDatabaseRegistrationOptionsModel.DatabaseType).To(Equal(core.StringPtr("db2")))
				Expect(createDatabaseRegistrationOptionsModel.AssociatedCatalog).To(Equal(databaseCatalogModel))
				Expect(createDatabaseRegistrationOptionsModel.CreatedOn).To(Equal(core.StringPtr("1686792721")))
				Expect(createDatabaseRegistrationOptionsModel.DatabaseDetails).To(Equal(databaseDetailsModel))
				Expect(createDatabaseRegistrationOptionsModel.DatabaseProperties).To(Equal([]watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems{*databaseRegistrationPrototypeDatabasePropertiesItemsModel}))
				Expect(createDatabaseRegistrationOptionsModel.Description).To(Equal(core.StringPtr("db2 extenal database description")))
				Expect(createDatabaseRegistrationOptionsModel.Tags).To(Equal([]string{"testdatabase", "userdatabase"}))
				Expect(createDatabaseRegistrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createDatabaseRegistrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateDb2EngineOptions successfully`, func() {
				// Construct an instance of the Db2EngineDetailsBody model
				db2EngineDetailsBodyModel := new(watsonxdatav2.Db2EngineDetailsBody)
				Expect(db2EngineDetailsBodyModel).ToNot(BeNil())
				db2EngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				Expect(db2EngineDetailsBodyModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))

				// Construct an instance of the CreateDb2EngineOptions model
				createDb2EngineOptionsOrigin := "external"
				createDb2EngineOptionsModel := watsonxDataService.NewCreateDb2EngineOptions(createDb2EngineOptionsOrigin)
				createDb2EngineOptionsModel.SetOrigin("external")
				createDb2EngineOptionsModel.SetDescription("db2 engine description")
				createDb2EngineOptionsModel.SetEngineDetails(db2EngineDetailsBodyModel)
				createDb2EngineOptionsModel.SetEngineDisplayName("sampleEngine")
				createDb2EngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createDb2EngineOptionsModel.SetAuthInstanceID("testString")
				createDb2EngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createDb2EngineOptionsModel).ToNot(BeNil())
				Expect(createDb2EngineOptionsModel.Origin).To(Equal(core.StringPtr("external")))
				Expect(createDb2EngineOptionsModel.Description).To(Equal(core.StringPtr("db2 engine description")))
				Expect(createDb2EngineOptionsModel.EngineDetails).To(Equal(db2EngineDetailsBodyModel))
				Expect(createDb2EngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine")))
				Expect(createDb2EngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createDb2EngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createDb2EngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateIngestionJobsLocalFilesOptions successfully`, func() {
				// Construct an instance of the CreateIngestionJobsLocalFilesOptions model
				authInstanceID := "testString"
				sourceDataFile := CreateMockReader("This is a mock file.")
				targetTable := "testString"
				jobID := "testString"
				username := "testString"
				createIngestionJobsLocalFilesOptionsModel := watsonxDataService.NewCreateIngestionJobsLocalFilesOptions(authInstanceID, sourceDataFile, targetTable, jobID, username)
				createIngestionJobsLocalFilesOptionsModel.SetAuthInstanceID("testString")
				createIngestionJobsLocalFilesOptionsModel.SetSourceDataFile(CreateMockReader("This is a mock file."))
				createIngestionJobsLocalFilesOptionsModel.SetTargetTable("testString")
				createIngestionJobsLocalFilesOptionsModel.SetJobID("testString")
				createIngestionJobsLocalFilesOptionsModel.SetUsername("testString")
				createIngestionJobsLocalFilesOptionsModel.SetSourceDataFileContentType("testString")
				createIngestionJobsLocalFilesOptionsModel.SetSourceFileType("csv")
				createIngestionJobsLocalFilesOptionsModel.SetCsvProperty("testString")
				createIngestionJobsLocalFilesOptionsModel.SetCreateIfNotExist(false)
				createIngestionJobsLocalFilesOptionsModel.SetValidateCsvHeader(false)
				createIngestionJobsLocalFilesOptionsModel.SetExecuteConfig("testString")
				createIngestionJobsLocalFilesOptionsModel.SetEngineID("testString")
				createIngestionJobsLocalFilesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createIngestionJobsLocalFilesOptionsModel).ToNot(BeNil())
				Expect(createIngestionJobsLocalFilesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.SourceDataFile).To(Equal(CreateMockReader("This is a mock file.")))
				Expect(createIngestionJobsLocalFilesOptionsModel.TargetTable).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.JobID).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.Username).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.SourceDataFileContentType).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.SourceFileType).To(Equal(core.StringPtr("csv")))
				Expect(createIngestionJobsLocalFilesOptionsModel.CsvProperty).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.CreateIfNotExist).To(Equal(core.BoolPtr(false)))
				Expect(createIngestionJobsLocalFilesOptionsModel.ValidateCsvHeader).To(Equal(core.BoolPtr(false)))
				Expect(createIngestionJobsLocalFilesOptionsModel.ExecuteConfig).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsLocalFilesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateIngestionJobsOptions successfully`, func() {
				// Construct an instance of the IngestionJobPrototypeCsvProperty model
				ingestionJobPrototypeCsvPropertyModel := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
				Expect(ingestionJobPrototypeCsvPropertyModel).ToNot(BeNil())
				ingestionJobPrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				ingestionJobPrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				ingestionJobPrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				ingestionJobPrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				ingestionJobPrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")
				Expect(ingestionJobPrototypeCsvPropertyModel.Encoding).To(Equal(core.StringPtr("utf-8")))
				Expect(ingestionJobPrototypeCsvPropertyModel.EscapeCharacter).To(Equal(core.StringPtr("\\\\")))
				Expect(ingestionJobPrototypeCsvPropertyModel.FieldDelimiter).To(Equal(core.StringPtr(",")))
				Expect(ingestionJobPrototypeCsvPropertyModel.Header).To(Equal(core.BoolPtr(true)))
				Expect(ingestionJobPrototypeCsvPropertyModel.LineDelimiter).To(Equal(core.StringPtr("\\n")))

				// Construct an instance of the IngestionJobPrototypeExecuteConfig model
				ingestionJobPrototypeExecuteConfigModel := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
				Expect(ingestionJobPrototypeExecuteConfigModel).ToNot(BeNil())
				ingestionJobPrototypeExecuteConfigModel.DriverCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.DriverMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.ExecutorCores = core.Int64Ptr(int64(1))
				ingestionJobPrototypeExecuteConfigModel.ExecutorMemory = core.StringPtr("2G")
				ingestionJobPrototypeExecuteConfigModel.NumExecutors = core.Int64Ptr(int64(1))
				Expect(ingestionJobPrototypeExecuteConfigModel.DriverCores).To(Equal(core.Int64Ptr(int64(1))))
				Expect(ingestionJobPrototypeExecuteConfigModel.DriverMemory).To(Equal(core.StringPtr("2G")))
				Expect(ingestionJobPrototypeExecuteConfigModel.ExecutorCores).To(Equal(core.Int64Ptr(int64(1))))
				Expect(ingestionJobPrototypeExecuteConfigModel.ExecutorMemory).To(Equal(core.StringPtr("2G")))
				Expect(ingestionJobPrototypeExecuteConfigModel.NumExecutors).To(Equal(core.Int64Ptr(int64(1))))

				// Construct an instance of the CreateIngestionJobsOptions model
				authInstanceID := "testString"
				createIngestionJobsOptionsJobID := "ingestion-1699459946935"
				createIngestionJobsOptionsSourceDataFiles := "s3://demobucket/data/yellow_tripdata_2022-01.parquet"
				createIngestionJobsOptionsTargetTable := "demodb.test.targettable"
				createIngestionJobsOptionsUsername := "user1"
				createIngestionJobsOptionsModel := watsonxDataService.NewCreateIngestionJobsOptions(authInstanceID, createIngestionJobsOptionsJobID, createIngestionJobsOptionsSourceDataFiles, createIngestionJobsOptionsTargetTable, createIngestionJobsOptionsUsername)
				createIngestionJobsOptionsModel.SetAuthInstanceID("testString")
				createIngestionJobsOptionsModel.SetJobID("ingestion-1699459946935")
				createIngestionJobsOptionsModel.SetSourceDataFiles("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createIngestionJobsOptionsModel.SetTargetTable("demodb.test.targettable")
				createIngestionJobsOptionsModel.SetUsername("user1")
				createIngestionJobsOptionsModel.SetCreateIfNotExist(false)
				createIngestionJobsOptionsModel.SetCsvProperty(ingestionJobPrototypeCsvPropertyModel)
				createIngestionJobsOptionsModel.SetEngineID("spark123")
				createIngestionJobsOptionsModel.SetExecuteConfig(ingestionJobPrototypeExecuteConfigModel)
				createIngestionJobsOptionsModel.SetPartitionBy("col1, col2")
				createIngestionJobsOptionsModel.SetSchema("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")
				createIngestionJobsOptionsModel.SetSourceFileType("csv")
				createIngestionJobsOptionsModel.SetValidateCsvHeader(false)
				createIngestionJobsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createIngestionJobsOptionsModel).ToNot(BeNil())
				Expect(createIngestionJobsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createIngestionJobsOptionsModel.JobID).To(Equal(core.StringPtr("ingestion-1699459946935")))
				Expect(createIngestionJobsOptionsModel.SourceDataFiles).To(Equal(core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")))
				Expect(createIngestionJobsOptionsModel.TargetTable).To(Equal(core.StringPtr("demodb.test.targettable")))
				Expect(createIngestionJobsOptionsModel.Username).To(Equal(core.StringPtr("user1")))
				Expect(createIngestionJobsOptionsModel.CreateIfNotExist).To(Equal(core.BoolPtr(false)))
				Expect(createIngestionJobsOptionsModel.CsvProperty).To(Equal(ingestionJobPrototypeCsvPropertyModel))
				Expect(createIngestionJobsOptionsModel.EngineID).To(Equal(core.StringPtr("spark123")))
				Expect(createIngestionJobsOptionsModel.ExecuteConfig).To(Equal(ingestionJobPrototypeExecuteConfigModel))
				Expect(createIngestionJobsOptionsModel.PartitionBy).To(Equal(core.StringPtr("col1, col2")))
				Expect(createIngestionJobsOptionsModel.Schema).To(Equal(core.StringPtr("{\"type\":\"struct\",\"schema-id\":0,\"fields\":[{\"id\":1,\"name\":\"ID\",\"required\":true,\"type\":\"int\"},{\"id\":2,\"name\":\"Name\",\"required\":true,\"type\":\"string\"}]}")))
				Expect(createIngestionJobsOptionsModel.SourceFileType).To(Equal(core.StringPtr("csv")))
				Expect(createIngestionJobsOptionsModel.ValidateCsvHeader).To(Equal(core.BoolPtr(false)))
				Expect(createIngestionJobsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateMilvusServiceOptions successfully`, func() {
				// Construct an instance of the CreateMilvusServiceOptions model
				createMilvusServiceOptionsOrigin := "native"
				createMilvusServiceOptionsModel := watsonxDataService.NewCreateMilvusServiceOptions(createMilvusServiceOptionsOrigin)
				createMilvusServiceOptionsModel.SetOrigin("native")
				createMilvusServiceOptionsModel.SetDescription("milvus service for running sql queries")
				createMilvusServiceOptionsModel.SetServiceDisplayName("sampleService")
				createMilvusServiceOptionsModel.SetTags([]string{"tag1", "tag2"})
				createMilvusServiceOptionsModel.SetAuthInstanceID("testString")
				createMilvusServiceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createMilvusServiceOptionsModel).ToNot(BeNil())
				Expect(createMilvusServiceOptionsModel.Origin).To(Equal(core.StringPtr("native")))
				Expect(createMilvusServiceOptionsModel.Description).To(Equal(core.StringPtr("milvus service for running sql queries")))
				Expect(createMilvusServiceOptionsModel.ServiceDisplayName).To(Equal(core.StringPtr("sampleService")))
				Expect(createMilvusServiceOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createMilvusServiceOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createMilvusServiceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateNetezzaEngineOptions successfully`, func() {
				// Construct an instance of the NetezzaEngineDetailsBody model
				netezzaEngineDetailsBodyModel := new(watsonxdatav2.NetezzaEngineDetailsBody)
				Expect(netezzaEngineDetailsBodyModel).ToNot(BeNil())
				netezzaEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				Expect(netezzaEngineDetailsBodyModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))

				// Construct an instance of the CreateNetezzaEngineOptions model
				createNetezzaEngineOptionsOrigin := "external"
				createNetezzaEngineOptionsModel := watsonxDataService.NewCreateNetezzaEngineOptions(createNetezzaEngineOptionsOrigin)
				createNetezzaEngineOptionsModel.SetOrigin("external")
				createNetezzaEngineOptionsModel.SetDescription("netezza engine description")
				createNetezzaEngineOptionsModel.SetEngineDetails(netezzaEngineDetailsBodyModel)
				createNetezzaEngineOptionsModel.SetEngineDisplayName("sampleEngine")
				createNetezzaEngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createNetezzaEngineOptionsModel.SetAuthInstanceID("testString")
				createNetezzaEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createNetezzaEngineOptionsModel).ToNot(BeNil())
				Expect(createNetezzaEngineOptionsModel.Origin).To(Equal(core.StringPtr("external")))
				Expect(createNetezzaEngineOptionsModel.Description).To(Equal(core.StringPtr("netezza engine description")))
				Expect(createNetezzaEngineOptionsModel.EngineDetails).To(Equal(netezzaEngineDetailsBodyModel))
				Expect(createNetezzaEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine")))
				Expect(createNetezzaEngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createNetezzaEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createNetezzaEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateOtherEngineOptions successfully`, func() {
				// Construct an instance of the OtherEngineDetailsBody model
				otherEngineDetailsBodyModel := new(watsonxdatav2.OtherEngineDetailsBody)
				Expect(otherEngineDetailsBodyModel).ToNot(BeNil())
				otherEngineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				otherEngineDetailsBodyModel.EngineType = core.StringPtr("netezza")
				Expect(otherEngineDetailsBodyModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(otherEngineDetailsBodyModel.EngineType).To(Equal(core.StringPtr("netezza")))

				// Construct an instance of the CreateOtherEngineOptions model
				var createOtherEngineOptionsEngineDetails *watsonxdatav2.OtherEngineDetailsBody = nil
				createOtherEngineOptionsEngineDisplayName := "sampleEngine01"
				createOtherEngineOptionsModel := watsonxDataService.NewCreateOtherEngineOptions(createOtherEngineOptionsEngineDetails, createOtherEngineOptionsEngineDisplayName)
				createOtherEngineOptionsModel.SetEngineDetails(otherEngineDetailsBodyModel)
				createOtherEngineOptionsModel.SetEngineDisplayName("sampleEngine01")
				createOtherEngineOptionsModel.SetDescription("external engine description")
				createOtherEngineOptionsModel.SetOrigin("external")
				createOtherEngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createOtherEngineOptionsModel.SetType("netezza")
				createOtherEngineOptionsModel.SetAuthInstanceID("testString")
				createOtherEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createOtherEngineOptionsModel).ToNot(BeNil())
				Expect(createOtherEngineOptionsModel.EngineDetails).To(Equal(otherEngineDetailsBodyModel))
				Expect(createOtherEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine01")))
				Expect(createOtherEngineOptionsModel.Description).To(Equal(core.StringPtr("external engine description")))
				Expect(createOtherEngineOptionsModel.Origin).To(Equal(core.StringPtr("external")))
				Expect(createOtherEngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createOtherEngineOptionsModel.Type).To(Equal(core.StringPtr("netezza")))
				Expect(createOtherEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createOtherEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreatePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				Expect(prestissimoNodeDescriptionBodyModel).ToNot(BeNil())
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))
				Expect(prestissimoNodeDescriptionBodyModel.NodeType).To(Equal(core.StringPtr("worker")))
				Expect(prestissimoNodeDescriptionBodyModel.Quantity).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the PrestissimoEndpoints model
				prestissimoEndpointsModel := new(watsonxdatav2.PrestissimoEndpoints)
				Expect(prestissimoEndpointsModel).ToNot(BeNil())
				prestissimoEndpointsModel.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
				prestissimoEndpointsModel.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
				prestissimoEndpointsModel.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
				prestissimoEndpointsModel.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
				prestissimoEndpointsModel.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
				prestissimoEndpointsModel.ViewHistoryServer = core.StringPtr("testString")
				prestissimoEndpointsModel.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")
				Expect(prestissimoEndpointsModel.ApplicationsApi).To(Equal(core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")))
				Expect(prestissimoEndpointsModel.HistoryServerEndpoint).To(Equal(core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")))
				Expect(prestissimoEndpointsModel.SparkAccessEndpoint).To(Equal(core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")))
				Expect(prestissimoEndpointsModel.SparkJobsV4Endpoint).To(Equal(core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")))
				Expect(prestissimoEndpointsModel.SparkKernelEndpoint).To(Equal(core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")))
				Expect(prestissimoEndpointsModel.ViewHistoryServer).To(Equal(core.StringPtr("testString")))
				Expect(prestissimoEndpointsModel.WxdApplicationEndpoint).To(Equal(core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")))

				// Construct an instance of the PrestissimoEngineDetails model
				prestissimoEngineDetailsModel := new(watsonxdatav2.PrestissimoEngineDetails)
				Expect(prestissimoEngineDetailsModel).ToNot(BeNil())
				prestissimoEngineDetailsModel.ApiKey = core.StringPtr("<api_key>")
				prestissimoEngineDetailsModel.ConnectionString = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.Coordinator = prestissimoNodeDescriptionBodyModel
				prestissimoEngineDetailsModel.Endpoints = prestissimoEndpointsModel
				prestissimoEngineDetailsModel.InstanceID = core.StringPtr("instance_id")
				prestissimoEngineDetailsModel.ManagedBy = core.StringPtr("fully/self")
				prestissimoEngineDetailsModel.MetastoreHost = core.StringPtr("1.2.3.4")
				prestissimoEngineDetailsModel.SizeConfig = core.StringPtr("starter")
				prestissimoEngineDetailsModel.Worker = prestissimoNodeDescriptionBodyModel
				Expect(prestissimoEngineDetailsModel.ApiKey).To(Equal(core.StringPtr("<api_key>")))
				Expect(prestissimoEngineDetailsModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(prestissimoEngineDetailsModel.Coordinator).To(Equal(prestissimoNodeDescriptionBodyModel))
				Expect(prestissimoEngineDetailsModel.Endpoints).To(Equal(prestissimoEndpointsModel))
				Expect(prestissimoEngineDetailsModel.InstanceID).To(Equal(core.StringPtr("instance_id")))
				Expect(prestissimoEngineDetailsModel.ManagedBy).To(Equal(core.StringPtr("fully/self")))
				Expect(prestissimoEngineDetailsModel.MetastoreHost).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(prestissimoEngineDetailsModel.SizeConfig).To(Equal(core.StringPtr("starter")))
				Expect(prestissimoEngineDetailsModel.Worker).To(Equal(prestissimoNodeDescriptionBodyModel))

				// Construct an instance of the CreatePrestissimoEngineOptions model
				createPrestissimoEngineOptionsOrigin := "native"
				createPrestissimoEngineOptionsModel := watsonxDataService.NewCreatePrestissimoEngineOptions(createPrestissimoEngineOptionsOrigin)
				createPrestissimoEngineOptionsModel.SetOrigin("native")
				createPrestissimoEngineOptionsModel.SetAssociatedCatalogs([]string{"hive_data"})
				createPrestissimoEngineOptionsModel.SetDescription("prestissimo engine description")
				createPrestissimoEngineOptionsModel.SetEngineDetails(prestissimoEngineDetailsModel)
				createPrestissimoEngineOptionsModel.SetEngineDisplayName("sampleEngine")
				createPrestissimoEngineOptionsModel.SetRegion("us-south")
				createPrestissimoEngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createPrestissimoEngineOptionsModel.SetVersion("1.2.3")
				createPrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				createPrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createPrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(createPrestissimoEngineOptionsModel.Origin).To(Equal(core.StringPtr("native")))
				Expect(createPrestissimoEngineOptionsModel.AssociatedCatalogs).To(Equal([]string{"hive_data"}))
				Expect(createPrestissimoEngineOptionsModel.Description).To(Equal(core.StringPtr("prestissimo engine description")))
				Expect(createPrestissimoEngineOptionsModel.EngineDetails).To(Equal(prestissimoEngineDetailsModel))
				Expect(createPrestissimoEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine")))
				Expect(createPrestissimoEngineOptionsModel.Region).To(Equal(core.StringPtr("us-south")))
				Expect(createPrestissimoEngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createPrestissimoEngineOptionsModel.Version).To(Equal(core.StringPtr("1.2.3")))
				Expect(createPrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createPrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreatePrestoEngineOptions successfully`, func() {
				// Construct an instance of the NodeDescriptionBody model
				nodeDescriptionBodyModel := new(watsonxdatav2.NodeDescriptionBody)
				Expect(nodeDescriptionBodyModel).ToNot(BeNil())
				nodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				nodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))
				Expect(nodeDescriptionBodyModel.NodeType).To(Equal(core.StringPtr("worker")))
				Expect(nodeDescriptionBodyModel.Quantity).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the EngineDetailsBody model
				engineDetailsBodyModel := new(watsonxdatav2.EngineDetailsBody)
				Expect(engineDetailsBodyModel).ToNot(BeNil())
				engineDetailsBodyModel.ApiKey = core.StringPtr("<api_key>")
				engineDetailsBodyModel.ConnectionString = core.StringPtr("1.2.3.4")
				engineDetailsBodyModel.Coordinator = nodeDescriptionBodyModel
				engineDetailsBodyModel.InstanceID = core.StringPtr("instance_id")
				engineDetailsBodyModel.ManagedBy = core.StringPtr("fully/self")
				engineDetailsBodyModel.SizeConfig = core.StringPtr("starter")
				engineDetailsBodyModel.Worker = nodeDescriptionBodyModel
				Expect(engineDetailsBodyModel.ApiKey).To(Equal(core.StringPtr("<api_key>")))
				Expect(engineDetailsBodyModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(engineDetailsBodyModel.Coordinator).To(Equal(nodeDescriptionBodyModel))
				Expect(engineDetailsBodyModel.InstanceID).To(Equal(core.StringPtr("instance_id")))
				Expect(engineDetailsBodyModel.ManagedBy).To(Equal(core.StringPtr("fully/self")))
				Expect(engineDetailsBodyModel.SizeConfig).To(Equal(core.StringPtr("starter")))
				Expect(engineDetailsBodyModel.Worker).To(Equal(nodeDescriptionBodyModel))

				// Construct an instance of the CreatePrestoEngineOptions model
				createPrestoEngineOptionsOrigin := "native"
				createPrestoEngineOptionsModel := watsonxDataService.NewCreatePrestoEngineOptions(createPrestoEngineOptionsOrigin)
				createPrestoEngineOptionsModel.SetOrigin("native")
				createPrestoEngineOptionsModel.SetAssociatedCatalogs([]string{"iceberg_data", "hive_data"})
				createPrestoEngineOptionsModel.SetDescription("presto engine for running sql queries")
				createPrestoEngineOptionsModel.SetEngineDetails(engineDetailsBodyModel)
				createPrestoEngineOptionsModel.SetEngineDisplayName("sampleEngine")
				createPrestoEngineOptionsModel.SetRegion("us-south")
				createPrestoEngineOptionsModel.SetTags([]string{"tag1", "tag2"})
				createPrestoEngineOptionsModel.SetVersion("1.2.3")
				createPrestoEngineOptionsModel.SetAuthInstanceID("testString")
				createPrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createPrestoEngineOptionsModel).ToNot(BeNil())
				Expect(createPrestoEngineOptionsModel.Origin).To(Equal(core.StringPtr("native")))
				Expect(createPrestoEngineOptionsModel.AssociatedCatalogs).To(Equal([]string{"iceberg_data", "hive_data"}))
				Expect(createPrestoEngineOptionsModel.Description).To(Equal(core.StringPtr("presto engine for running sql queries")))
				Expect(createPrestoEngineOptionsModel.EngineDetails).To(Equal(engineDetailsBodyModel))
				Expect(createPrestoEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("sampleEngine")))
				Expect(createPrestoEngineOptionsModel.Region).To(Equal(core.StringPtr("us-south")))
				Expect(createPrestoEngineOptionsModel.Tags).To(Equal([]string{"tag1", "tag2"}))
				Expect(createPrestoEngineOptionsModel.Version).To(Equal(core.StringPtr("1.2.3")))
				Expect(createPrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createPrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreatePreviewIngestionFileOptions successfully`, func() {
				// Construct an instance of the PreviewIngestionFilePrototypeCsvProperty model
				previewIngestionFilePrototypeCsvPropertyModel := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
				Expect(previewIngestionFilePrototypeCsvPropertyModel).ToNot(BeNil())
				previewIngestionFilePrototypeCsvPropertyModel.Encoding = core.StringPtr("utf-8")
				previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter = core.StringPtr("\\\\")
				previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter = core.StringPtr(",")
				previewIngestionFilePrototypeCsvPropertyModel.Header = core.BoolPtr(true)
				previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter = core.StringPtr("\\n")
				Expect(previewIngestionFilePrototypeCsvPropertyModel.Encoding).To(Equal(core.StringPtr("utf-8")))
				Expect(previewIngestionFilePrototypeCsvPropertyModel.EscapeCharacter).To(Equal(core.StringPtr("\\\\")))
				Expect(previewIngestionFilePrototypeCsvPropertyModel.FieldDelimiter).To(Equal(core.StringPtr(",")))
				Expect(previewIngestionFilePrototypeCsvPropertyModel.Header).To(Equal(core.BoolPtr(true)))
				Expect(previewIngestionFilePrototypeCsvPropertyModel.LineDelimiter).To(Equal(core.StringPtr("\\n")))

				// Construct an instance of the CreatePreviewIngestionFileOptions model
				authInstanceID := "testString"
				createPreviewIngestionFileOptionsSourceDataFiles := "s3://demobucket/data/yellow_tripdata_2022-01.parquet"
				createPreviewIngestionFileOptionsModel := watsonxDataService.NewCreatePreviewIngestionFileOptions(authInstanceID, createPreviewIngestionFileOptionsSourceDataFiles)
				createPreviewIngestionFileOptionsModel.SetAuthInstanceID("testString")
				createPreviewIngestionFileOptionsModel.SetSourceDataFiles("s3://demobucket/data/yellow_tripdata_2022-01.parquet")
				createPreviewIngestionFileOptionsModel.SetCsvProperty(previewIngestionFilePrototypeCsvPropertyModel)
				createPreviewIngestionFileOptionsModel.SetSourceFileType("csv")
				createPreviewIngestionFileOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createPreviewIngestionFileOptionsModel).ToNot(BeNil())
				Expect(createPreviewIngestionFileOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createPreviewIngestionFileOptionsModel.SourceDataFiles).To(Equal(core.StringPtr("s3://demobucket/data/yellow_tripdata_2022-01.parquet")))
				Expect(createPreviewIngestionFileOptionsModel.CsvProperty).To(Equal(previewIngestionFilePrototypeCsvPropertyModel))
				Expect(createPreviewIngestionFileOptionsModel.SourceFileType).To(Equal(core.StringPtr("csv")))
				Expect(createPreviewIngestionFileOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSchemaOptions successfully`, func() {
				// Construct an instance of the CreateSchemaOptions model
				engineID := "testString"
				catalogID := "testString"
				createSchemaOptionsCustomPath := "sample-path"
				createSchemaOptionsSchemaName := "SampleSchema1"
				createSchemaOptionsModel := watsonxDataService.NewCreateSchemaOptions(engineID, catalogID, createSchemaOptionsCustomPath, createSchemaOptionsSchemaName)
				createSchemaOptionsModel.SetEngineID("testString")
				createSchemaOptionsModel.SetCatalogID("testString")
				createSchemaOptionsModel.SetCustomPath("sample-path")
				createSchemaOptionsModel.SetSchemaName("SampleSchema1")
				createSchemaOptionsModel.SetBucketName("sample-bucket")
				createSchemaOptionsModel.SetAuthInstanceID("testString")
				createSchemaOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSchemaOptionsModel).ToNot(BeNil())
				Expect(createSchemaOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createSchemaOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(createSchemaOptionsModel.CustomPath).To(Equal(core.StringPtr("sample-path")))
				Expect(createSchemaOptionsModel.SchemaName).To(Equal(core.StringPtr("SampleSchema1")))
				Expect(createSchemaOptionsModel.BucketName).To(Equal(core.StringPtr("sample-bucket")))
				Expect(createSchemaOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSchemaOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSparkEngineApplicationOptions successfully`, func() {
				// Construct an instance of the SparkApplicationConfig model
				sparkApplicationConfigModel := new(watsonxdatav2.SparkApplicationConfig)
				Expect(sparkApplicationConfigModel).ToNot(BeNil())
				sparkApplicationConfigModel.SparkSampleConfigProperpty = core.StringPtr("testString")
				Expect(sparkApplicationConfigModel.SparkSampleConfigProperpty).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SparkApplicationEnv model
				sparkApplicationEnvModel := new(watsonxdatav2.SparkApplicationEnv)
				Expect(sparkApplicationEnvModel).ToNot(BeNil())
				sparkApplicationEnvModel.SampleEnvKey = core.StringPtr("testString")
				Expect(sparkApplicationEnvModel.SampleEnvKey).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SparkApplicationDetails model
				sparkApplicationDetailsModel := new(watsonxdatav2.SparkApplicationDetails)
				Expect(sparkApplicationDetailsModel).ToNot(BeNil())
				sparkApplicationDetailsModel.Application = core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")
				sparkApplicationDetailsModel.Arguments = []string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}
				sparkApplicationDetailsModel.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
				sparkApplicationDetailsModel.Conf = sparkApplicationConfigModel
				sparkApplicationDetailsModel.Env = sparkApplicationEnvModel
				sparkApplicationDetailsModel.Files = core.StringPtr("s3://mybucket/myfile.txt")
				sparkApplicationDetailsModel.Jars = core.StringPtr("testString")
				sparkApplicationDetailsModel.Name = core.StringPtr("SparkApplicaton1")
				sparkApplicationDetailsModel.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
				sparkApplicationDetailsModel.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
				sparkApplicationDetailsModel.SparkVersion = core.StringPtr("3.3")
				Expect(sparkApplicationDetailsModel.Application).To(Equal(core.StringPtr("/opt/ibm/spark/examples/src/main/python/wordcount.py")))
				Expect(sparkApplicationDetailsModel.Arguments).To(Equal([]string{"/opt/ibm/spark/examples/src/main/resources/people.txt"}))
				Expect(sparkApplicationDetailsModel.Class).To(Equal(core.StringPtr("org.apache.spark.examples.SparkPi")))
				Expect(sparkApplicationDetailsModel.Conf).To(Equal(sparkApplicationConfigModel))
				Expect(sparkApplicationDetailsModel.Env).To(Equal(sparkApplicationEnvModel))
				Expect(sparkApplicationDetailsModel.Files).To(Equal(core.StringPtr("s3://mybucket/myfile.txt")))
				Expect(sparkApplicationDetailsModel.Jars).To(Equal(core.StringPtr("testString")))
				Expect(sparkApplicationDetailsModel.Name).To(Equal(core.StringPtr("SparkApplicaton1")))
				Expect(sparkApplicationDetailsModel.Packages).To(Equal(core.StringPtr("org.apache.spark:example_1.2.3")))
				Expect(sparkApplicationDetailsModel.Repositories).To(Equal(core.StringPtr("https://repo1.maven.org/maven2/")))
				Expect(sparkApplicationDetailsModel.SparkVersion).To(Equal(core.StringPtr("3.3")))

				// Construct an instance of the SparkVolumeDetails model
				sparkVolumeDetailsModel := new(watsonxdatav2.SparkVolumeDetails)
				Expect(sparkVolumeDetailsModel).ToNot(BeNil())
				sparkVolumeDetailsModel.MountPath = core.StringPtr("/mount/path")
				sparkVolumeDetailsModel.Name = core.StringPtr("my-volume")
				sparkVolumeDetailsModel.ReadOnly = core.BoolPtr(true)
				sparkVolumeDetailsModel.SourceSubPath = core.StringPtr("/source/path")
				Expect(sparkVolumeDetailsModel.MountPath).To(Equal(core.StringPtr("/mount/path")))
				Expect(sparkVolumeDetailsModel.Name).To(Equal(core.StringPtr("my-volume")))
				Expect(sparkVolumeDetailsModel.ReadOnly).To(Equal(core.BoolPtr(true)))
				Expect(sparkVolumeDetailsModel.SourceSubPath).To(Equal(core.StringPtr("/source/path")))

				// Construct an instance of the CreateSparkEngineApplicationOptions model
				engineID := "testString"
				var createSparkEngineApplicationOptionsApplicationDetails *watsonxdatav2.SparkApplicationDetails = nil
				createSparkEngineApplicationOptionsModel := watsonxDataService.NewCreateSparkEngineApplicationOptions(engineID, createSparkEngineApplicationOptionsApplicationDetails)
				createSparkEngineApplicationOptionsModel.SetEngineID("testString")
				createSparkEngineApplicationOptionsModel.SetApplicationDetails(sparkApplicationDetailsModel)
				createSparkEngineApplicationOptionsModel.SetJobEndpoint("testString")
				createSparkEngineApplicationOptionsModel.SetServiceInstanceID("testString")
				createSparkEngineApplicationOptionsModel.SetType("iae")
				createSparkEngineApplicationOptionsModel.SetVolumes([]watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel})
				createSparkEngineApplicationOptionsModel.SetAuthInstanceID("testString")
				createSparkEngineApplicationOptionsModel.SetState([]string{"testString"})
				createSparkEngineApplicationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSparkEngineApplicationOptionsModel).ToNot(BeNil())
				Expect(createSparkEngineApplicationOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineApplicationOptionsModel.ApplicationDetails).To(Equal(sparkApplicationDetailsModel))
				Expect(createSparkEngineApplicationOptionsModel.JobEndpoint).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineApplicationOptionsModel.ServiceInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineApplicationOptionsModel.Type).To(Equal(core.StringPtr("iae")))
				Expect(createSparkEngineApplicationOptionsModel.Volumes).To(Equal([]watsonxdatav2.SparkVolumeDetails{*sparkVolumeDetailsModel}))
				Expect(createSparkEngineApplicationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineApplicationOptionsModel.State).To(Equal([]string{"testString"}))
				Expect(createSparkEngineApplicationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSparkEngineOptions successfully`, func() {
				// Construct an instance of the SparkDefaultConfig model
				sparkDefaultConfigModel := new(watsonxdatav2.SparkDefaultConfig)
				Expect(sparkDefaultConfigModel).ToNot(BeNil())
				sparkDefaultConfigModel.Config1 = core.StringPtr("testString")
				sparkDefaultConfigModel.Config2 = core.StringPtr("testString")
				Expect(sparkDefaultConfigModel.Config1).To(Equal(core.StringPtr("testString")))
				Expect(sparkDefaultConfigModel.Config2).To(Equal(core.StringPtr("testString")))

				// Construct an instance of the SparkScaleConfig model
				sparkScaleConfigModel := new(watsonxdatav2.SparkScaleConfig)
				Expect(sparkScaleConfigModel).ToNot(BeNil())
				sparkScaleConfigModel.AutoScaleEnabled = core.BoolPtr(true)
				sparkScaleConfigModel.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
				sparkScaleConfigModel.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
				sparkScaleConfigModel.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
				sparkScaleConfigModel.NodeType = core.StringPtr("small")
				sparkScaleConfigModel.NumberOfNodes = core.Int64Ptr(int64(5))
				Expect(sparkScaleConfigModel.AutoScaleEnabled).To(Equal(core.BoolPtr(true)))
				Expect(sparkScaleConfigModel.CurrentNumberOfNodes).To(Equal(core.Int64Ptr(int64(2))))
				Expect(sparkScaleConfigModel.MaximumNumberOfNodes).To(Equal(core.Int64Ptr(int64(5))))
				Expect(sparkScaleConfigModel.MinimumNumberOfNodes).To(Equal(core.Int64Ptr(int64(1))))
				Expect(sparkScaleConfigModel.NodeType).To(Equal(core.StringPtr("small")))
				Expect(sparkScaleConfigModel.NumberOfNodes).To(Equal(core.Int64Ptr(int64(5))))

				// Construct an instance of the SparkEngineDetailsPrototype model
				sparkEngineDetailsPrototypeModel := new(watsonxdatav2.SparkEngineDetailsPrototype)
				Expect(sparkEngineDetailsPrototypeModel).ToNot(BeNil())
				sparkEngineDetailsPrototypeModel.ApiKey = core.StringPtr("apikey")
				sparkEngineDetailsPrototypeModel.ConnectionString = core.StringPtr("1.2.3.4")
				sparkEngineDetailsPrototypeModel.DefaultConfig = sparkDefaultConfigModel
				sparkEngineDetailsPrototypeModel.DefaultVersion = core.StringPtr("3.3")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
				sparkEngineDetailsPrototypeModel.EngineHomeBucketName = core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")
				sparkEngineDetailsPrototypeModel.EngineHomePath = core.StringPtr("spark/spark1234")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeID = core.StringPtr("1704979825978585")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeName = core.StringPtr("my-volume")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
				sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
				sparkEngineDetailsPrototypeModel.InstanceID = core.StringPtr("spark-id")
				sparkEngineDetailsPrototypeModel.ManagedBy = core.StringPtr("fully/self")
				sparkEngineDetailsPrototypeModel.ScaleConfig = sparkScaleConfigModel
				Expect(sparkEngineDetailsPrototypeModel.ApiKey).To(Equal(core.StringPtr("apikey")))
				Expect(sparkEngineDetailsPrototypeModel.ConnectionString).To(Equal(core.StringPtr("1.2.3.4")))
				Expect(sparkEngineDetailsPrototypeModel.DefaultConfig).To(Equal(sparkDefaultConfigModel))
				Expect(sparkEngineDetailsPrototypeModel.DefaultVersion).To(Equal(core.StringPtr("3.3")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeBucketDisplayName).To(Equal(core.StringPtr("test-spark-bucket")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeBucketName).To(Equal(core.StringPtr("4fec0f8b-888a-4c16-8f38-250c8499e6ce-customer")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomePath).To(Equal(core.StringPtr("spark/spark1234")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeVolumeID).To(Equal(core.StringPtr("1704979825978585")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeVolumeName).To(Equal(core.StringPtr("my-volume")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageClass).To(Equal(core.StringPtr("nfs-client")))
				Expect(sparkEngineDetailsPrototypeModel.EngineHomeVolumeStorageSize).To(Equal(core.StringPtr("5Gi")))
				Expect(sparkEngineDetailsPrototypeModel.InstanceID).To(Equal(core.StringPtr("spark-id")))
				Expect(sparkEngineDetailsPrototypeModel.ManagedBy).To(Equal(core.StringPtr("fully/self")))
				Expect(sparkEngineDetailsPrototypeModel.ScaleConfig).To(Equal(sparkScaleConfigModel))

				// Construct an instance of the CreateSparkEngineOptions model
				createSparkEngineOptionsOrigin := "native"
				createSparkEngineOptionsModel := watsonxDataService.NewCreateSparkEngineOptions(createSparkEngineOptionsOrigin)
				createSparkEngineOptionsModel.SetOrigin("native")
				createSparkEngineOptionsModel.SetAssociatedCatalogs([]string{"iceberg_data"})
				createSparkEngineOptionsModel.SetDescription("testString")
				createSparkEngineOptionsModel.SetEngineDetails(sparkEngineDetailsPrototypeModel)
				createSparkEngineOptionsModel.SetEngineDisplayName("test-native")
				createSparkEngineOptionsModel.SetStatus("testString")
				createSparkEngineOptionsModel.SetTags([]string{"testString"})
				createSparkEngineOptionsModel.SetAuthInstanceID("testString")
				createSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSparkEngineOptionsModel).ToNot(BeNil())
				Expect(createSparkEngineOptionsModel.Origin).To(Equal(core.StringPtr("native")))
				Expect(createSparkEngineOptionsModel.AssociatedCatalogs).To(Equal([]string{"iceberg_data"}))
				Expect(createSparkEngineOptionsModel.Description).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineOptionsModel.EngineDetails).To(Equal(sparkEngineDetailsPrototypeModel))
				Expect(createSparkEngineOptionsModel.EngineDisplayName).To(Equal(core.StringPtr("test-native")))
				Expect(createSparkEngineOptionsModel.Status).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineOptionsModel.Tags).To(Equal([]string{"testString"}))
				Expect(createSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSparkEnginePauseOptions successfully`, func() {
				// Construct an instance of the CreateSparkEnginePauseOptions model
				engineID := "testString"
				createSparkEnginePauseOptionsModel := watsonxDataService.NewCreateSparkEnginePauseOptions(engineID)
				createSparkEnginePauseOptionsModel.SetEngineID("testString")
				createSparkEnginePauseOptionsModel.SetAuthInstanceID("testString")
				createSparkEnginePauseOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSparkEnginePauseOptionsModel).ToNot(BeNil())
				Expect(createSparkEnginePauseOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEnginePauseOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEnginePauseOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSparkEngineResumeOptions successfully`, func() {
				// Construct an instance of the CreateSparkEngineResumeOptions model
				engineID := "testString"
				createSparkEngineResumeOptionsModel := watsonxDataService.NewCreateSparkEngineResumeOptions(engineID)
				createSparkEngineResumeOptionsModel.SetEngineID("testString")
				createSparkEngineResumeOptionsModel.SetAuthInstanceID("testString")
				createSparkEngineResumeOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSparkEngineResumeOptionsModel).ToNot(BeNil())
				Expect(createSparkEngineResumeOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineResumeOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineResumeOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewCreateSparkEngineScaleOptions successfully`, func() {
				// Construct an instance of the CreateSparkEngineScaleOptions model
				engineID := "testString"
				createSparkEngineScaleOptionsModel := watsonxDataService.NewCreateSparkEngineScaleOptions(engineID)
				createSparkEngineScaleOptionsModel.SetEngineID("testString")
				createSparkEngineScaleOptionsModel.SetNumberOfNodes(int64(2))
				createSparkEngineScaleOptionsModel.SetAuthInstanceID("testString")
				createSparkEngineScaleOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(createSparkEngineScaleOptionsModel).ToNot(BeNil())
				Expect(createSparkEngineScaleOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineScaleOptionsModel.NumberOfNodes).To(Equal(core.Int64Ptr(int64(2))))
				Expect(createSparkEngineScaleOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(createSparkEngineScaleOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDatabaseDetails successfully`, func() {
				hostname := "db2@<hostname>.com"
				port := int64(4553)
				_model, err := watsonxDataService.NewDatabaseDetails(hostname, port)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewDatabaseRegistrationPrototypeDatabasePropertiesItems successfully`, func() {
				encrypt := true
				key := "hive.metastore"
				value := "glue"
				_model, err := watsonxDataService.NewDatabaseRegistrationPrototypeDatabasePropertiesItems(encrypt, key, value)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewDeleteColumnOptions successfully`, func() {
				// Construct an instance of the DeleteColumnOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				columnID := "testString"
				deleteColumnOptionsModel := watsonxDataService.NewDeleteColumnOptions(engineID, catalogID, schemaID, tableID, columnID)
				deleteColumnOptionsModel.SetEngineID("testString")
				deleteColumnOptionsModel.SetCatalogID("testString")
				deleteColumnOptionsModel.SetSchemaID("testString")
				deleteColumnOptionsModel.SetTableID("testString")
				deleteColumnOptionsModel.SetColumnID("testString")
				deleteColumnOptionsModel.SetAuthInstanceID("testString")
				deleteColumnOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteColumnOptionsModel).ToNot(BeNil())
				Expect(deleteColumnOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.ColumnID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteColumnOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteDatabaseCatalogOptions successfully`, func() {
				// Construct an instance of the DeleteDatabaseCatalogOptions model
				databaseID := "testString"
				deleteDatabaseCatalogOptionsModel := watsonxDataService.NewDeleteDatabaseCatalogOptions(databaseID)
				deleteDatabaseCatalogOptionsModel.SetDatabaseID("testString")
				deleteDatabaseCatalogOptionsModel.SetAuthInstanceID("testString")
				deleteDatabaseCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteDatabaseCatalogOptionsModel).ToNot(BeNil())
				Expect(deleteDatabaseCatalogOptionsModel.DatabaseID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDatabaseCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDatabaseCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteDb2EngineOptions successfully`, func() {
				// Construct an instance of the DeleteDb2EngineOptions model
				engineID := "testString"
				deleteDb2EngineOptionsModel := watsonxDataService.NewDeleteDb2EngineOptions(engineID)
				deleteDb2EngineOptionsModel.SetEngineID("testString")
				deleteDb2EngineOptionsModel.SetAuthInstanceID("testString")
				deleteDb2EngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteDb2EngineOptionsModel).ToNot(BeNil())
				Expect(deleteDb2EngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDb2EngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDb2EngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteDeactivateBucketOptions successfully`, func() {
				// Construct an instance of the DeleteDeactivateBucketOptions model
				bucketID := "testString"
				deleteDeactivateBucketOptionsModel := watsonxDataService.NewDeleteDeactivateBucketOptions(bucketID)
				deleteDeactivateBucketOptionsModel.SetBucketID("testString")
				deleteDeactivateBucketOptionsModel.SetAuthInstanceID("testString")
				deleteDeactivateBucketOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteDeactivateBucketOptionsModel).ToNot(BeNil())
				Expect(deleteDeactivateBucketOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDeactivateBucketOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteDeactivateBucketOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteEngineOptions successfully`, func() {
				// Construct an instance of the DeleteEngineOptions model
				engineID := "testString"
				deleteEngineOptionsModel := watsonxDataService.NewDeleteEngineOptions(engineID)
				deleteEngineOptionsModel.SetEngineID("testString")
				deleteEngineOptionsModel.SetAuthInstanceID("testString")
				deleteEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteEngineOptionsModel).ToNot(BeNil())
				Expect(deleteEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteIngestionJobsOptions successfully`, func() {
				// Construct an instance of the DeleteIngestionJobsOptions model
				jobID := "testString"
				authInstanceID := "testString"
				deleteIngestionJobsOptionsModel := watsonxDataService.NewDeleteIngestionJobsOptions(jobID, authInstanceID)
				deleteIngestionJobsOptionsModel.SetJobID("testString")
				deleteIngestionJobsOptionsModel.SetAuthInstanceID("testString")
				deleteIngestionJobsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteIngestionJobsOptionsModel).ToNot(BeNil())
				Expect(deleteIngestionJobsOptionsModel.JobID).To(Equal(core.StringPtr("testString")))
				Expect(deleteIngestionJobsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteIngestionJobsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteMilvusServiceOptions successfully`, func() {
				// Construct an instance of the DeleteMilvusServiceOptions model
				serviceID := "testString"
				deleteMilvusServiceOptionsModel := watsonxDataService.NewDeleteMilvusServiceOptions(serviceID)
				deleteMilvusServiceOptionsModel.SetServiceID("testString")
				deleteMilvusServiceOptionsModel.SetAuthInstanceID("testString")
				deleteMilvusServiceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteMilvusServiceOptionsModel).ToNot(BeNil())
				Expect(deleteMilvusServiceOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteMilvusServiceOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteMilvusServiceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteNetezzaEngineOptions successfully`, func() {
				// Construct an instance of the DeleteNetezzaEngineOptions model
				engineID := "testString"
				deleteNetezzaEngineOptionsModel := watsonxDataService.NewDeleteNetezzaEngineOptions(engineID)
				deleteNetezzaEngineOptionsModel.SetEngineID("testString")
				deleteNetezzaEngineOptionsModel.SetAuthInstanceID("testString")
				deleteNetezzaEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteNetezzaEngineOptionsModel).ToNot(BeNil())
				Expect(deleteNetezzaEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteNetezzaEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteNetezzaEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteOtherEngineOptions successfully`, func() {
				// Construct an instance of the DeleteOtherEngineOptions model
				engineID := "testString"
				deleteOtherEngineOptionsModel := watsonxDataService.NewDeleteOtherEngineOptions(engineID)
				deleteOtherEngineOptionsModel.SetEngineID("testString")
				deleteOtherEngineOptionsModel.SetAuthInstanceID("testString")
				deleteOtherEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteOtherEngineOptionsModel).ToNot(BeNil())
				Expect(deleteOtherEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOtherEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteOtherEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeletePrestissimoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the DeletePrestissimoEngineCatalogsOptions model
				engineID := "testString"
				catalogNames := "testString"
				deletePrestissimoEngineCatalogsOptionsModel := watsonxDataService.NewDeletePrestissimoEngineCatalogsOptions(engineID, catalogNames)
				deletePrestissimoEngineCatalogsOptionsModel.SetEngineID("testString")
				deletePrestissimoEngineCatalogsOptionsModel.SetCatalogNames("testString")
				deletePrestissimoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				deletePrestissimoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deletePrestissimoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(deletePrestissimoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeletePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the DeletePrestissimoEngineOptions model
				engineID := "testString"
				deletePrestissimoEngineOptionsModel := watsonxDataService.NewDeletePrestissimoEngineOptions(engineID)
				deletePrestissimoEngineOptionsModel.SetEngineID("testString")
				deletePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				deletePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deletePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(deletePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeletePrestoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the DeletePrestoEngineCatalogsOptions model
				engineID := "testString"
				catalogNames := "testString"
				deletePrestoEngineCatalogsOptionsModel := watsonxDataService.NewDeletePrestoEngineCatalogsOptions(engineID, catalogNames)
				deletePrestoEngineCatalogsOptionsModel.SetEngineID("testString")
				deletePrestoEngineCatalogsOptionsModel.SetCatalogNames("testString")
				deletePrestoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				deletePrestoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deletePrestoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(deletePrestoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestoEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deletePrestoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSchemaOptions successfully`, func() {
				// Construct an instance of the DeleteSchemaOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				deleteSchemaOptionsModel := watsonxDataService.NewDeleteSchemaOptions(engineID, catalogID, schemaID)
				deleteSchemaOptionsModel.SetEngineID("testString")
				deleteSchemaOptionsModel.SetCatalogID("testString")
				deleteSchemaOptionsModel.SetSchemaID("testString")
				deleteSchemaOptionsModel.SetAuthInstanceID("testString")
				deleteSchemaOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSchemaOptionsModel).ToNot(BeNil())
				Expect(deleteSchemaOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSchemaOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSchemaOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSchemaOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSchemaOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSparkEngineApplicationsOptions successfully`, func() {
				// Construct an instance of the DeleteSparkEngineApplicationsOptions model
				engineID := "testString"
				applicationID := "testString"
				deleteSparkEngineApplicationsOptionsModel := watsonxDataService.NewDeleteSparkEngineApplicationsOptions(engineID, applicationID)
				deleteSparkEngineApplicationsOptionsModel.SetEngineID("testString")
				deleteSparkEngineApplicationsOptionsModel.SetApplicationID("testString")
				deleteSparkEngineApplicationsOptionsModel.SetAuthInstanceID("testString")
				deleteSparkEngineApplicationsOptionsModel.SetState([]string{"testString"})
				deleteSparkEngineApplicationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSparkEngineApplicationsOptionsModel).ToNot(BeNil())
				Expect(deleteSparkEngineApplicationsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineApplicationsOptionsModel.ApplicationID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineApplicationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineApplicationsOptionsModel.State).To(Equal([]string{"testString"}))
				Expect(deleteSparkEngineApplicationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSparkEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the DeleteSparkEngineCatalogsOptions model
				engineID := "testString"
				catalogNames := "testString"
				deleteSparkEngineCatalogsOptionsModel := watsonxDataService.NewDeleteSparkEngineCatalogsOptions(engineID, catalogNames)
				deleteSparkEngineCatalogsOptionsModel.SetEngineID("testString")
				deleteSparkEngineCatalogsOptionsModel.SetCatalogNames("testString")
				deleteSparkEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				deleteSparkEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSparkEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(deleteSparkEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineCatalogsOptionsModel.CatalogNames).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSparkEngineHistoryServerOptions successfully`, func() {
				// Construct an instance of the DeleteSparkEngineHistoryServerOptions model
				engineID := "testString"
				deleteSparkEngineHistoryServerOptionsModel := watsonxDataService.NewDeleteSparkEngineHistoryServerOptions(engineID)
				deleteSparkEngineHistoryServerOptionsModel.SetEngineID("testString")
				deleteSparkEngineHistoryServerOptionsModel.SetAuthInstanceID("testString")
				deleteSparkEngineHistoryServerOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSparkEngineHistoryServerOptionsModel).ToNot(BeNil())
				Expect(deleteSparkEngineHistoryServerOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineHistoryServerOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineHistoryServerOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteSparkEngineOptions successfully`, func() {
				// Construct an instance of the DeleteSparkEngineOptions model
				engineID := "testString"
				deleteSparkEngineOptionsModel := watsonxDataService.NewDeleteSparkEngineOptions(engineID)
				deleteSparkEngineOptionsModel.SetEngineID("testString")
				deleteSparkEngineOptionsModel.SetAuthInstanceID("testString")
				deleteSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteSparkEngineOptionsModel).ToNot(BeNil())
				Expect(deleteSparkEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeleteTableOptions successfully`, func() {
				// Construct an instance of the DeleteTableOptions model
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				engineID := "testString"
				deleteTableOptionsModel := watsonxDataService.NewDeleteTableOptions(catalogID, schemaID, tableID, engineID)
				deleteTableOptionsModel.SetCatalogID("testString")
				deleteTableOptionsModel.SetSchemaID("testString")
				deleteTableOptionsModel.SetTableID("testString")
				deleteTableOptionsModel.SetEngineID("testString")
				deleteTableOptionsModel.SetAuthInstanceID("testString")
				deleteTableOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deleteTableOptionsModel).ToNot(BeNil())
				Expect(deleteTableOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deleteTableOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewDeregisterBucketOptions successfully`, func() {
				// Construct an instance of the DeregisterBucketOptions model
				bucketID := "testString"
				deregisterBucketOptionsModel := watsonxDataService.NewDeregisterBucketOptions(bucketID)
				deregisterBucketOptionsModel.SetBucketID("testString")
				deregisterBucketOptionsModel.SetAuthInstanceID("testString")
				deregisterBucketOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(deregisterBucketOptionsModel).ToNot(BeNil())
				Expect(deregisterBucketOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(deregisterBucketOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(deregisterBucketOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetBucketRegistrationOptions successfully`, func() {
				// Construct an instance of the GetBucketRegistrationOptions model
				bucketID := "testString"
				getBucketRegistrationOptionsModel := watsonxDataService.NewGetBucketRegistrationOptions(bucketID)
				getBucketRegistrationOptionsModel.SetBucketID("testString")
				getBucketRegistrationOptionsModel.SetAuthInstanceID("testString")
				getBucketRegistrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getBucketRegistrationOptionsModel).ToNot(BeNil())
				Expect(getBucketRegistrationOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(getBucketRegistrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getBucketRegistrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetCatalogOptions successfully`, func() {
				// Construct an instance of the GetCatalogOptions model
				catalogID := "testString"
				getCatalogOptionsModel := watsonxDataService.NewGetCatalogOptions(catalogID)
				getCatalogOptionsModel.SetCatalogID("testString")
				getCatalogOptionsModel.SetAuthInstanceID("testString")
				getCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getCatalogOptionsModel).ToNot(BeNil())
				Expect(getCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetDatabaseOptions successfully`, func() {
				// Construct an instance of the GetDatabaseOptions model
				databaseID := "testString"
				getDatabaseOptionsModel := watsonxDataService.NewGetDatabaseOptions(databaseID)
				getDatabaseOptionsModel.SetDatabaseID("testString")
				getDatabaseOptionsModel.SetAuthInstanceID("testString")
				getDatabaseOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getDatabaseOptionsModel).ToNot(BeNil())
				Expect(getDatabaseOptionsModel.DatabaseID).To(Equal(core.StringPtr("testString")))
				Expect(getDatabaseOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getDatabaseOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetIngestionJobOptions successfully`, func() {
				// Construct an instance of the GetIngestionJobOptions model
				jobID := "testString"
				authInstanceID := "testString"
				getIngestionJobOptionsModel := watsonxDataService.NewGetIngestionJobOptions(jobID, authInstanceID)
				getIngestionJobOptionsModel.SetJobID("testString")
				getIngestionJobOptionsModel.SetAuthInstanceID("testString")
				getIngestionJobOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getIngestionJobOptionsModel).ToNot(BeNil())
				Expect(getIngestionJobOptionsModel.JobID).To(Equal(core.StringPtr("testString")))
				Expect(getIngestionJobOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getIngestionJobOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetMilvusServiceOptions successfully`, func() {
				// Construct an instance of the GetMilvusServiceOptions model
				serviceID := "testString"
				getMilvusServiceOptionsModel := watsonxDataService.NewGetMilvusServiceOptions(serviceID)
				getMilvusServiceOptionsModel.SetServiceID("testString")
				getMilvusServiceOptionsModel.SetAuthInstanceID("testString")
				getMilvusServiceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getMilvusServiceOptionsModel).ToNot(BeNil())
				Expect(getMilvusServiceOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(getMilvusServiceOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getMilvusServiceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPrestissimoEngineCatalogOptions successfully`, func() {
				// Construct an instance of the GetPrestissimoEngineCatalogOptions model
				engineID := "testString"
				catalogID := "testString"
				getPrestissimoEngineCatalogOptionsModel := watsonxDataService.NewGetPrestissimoEngineCatalogOptions(engineID, catalogID)
				getPrestissimoEngineCatalogOptionsModel.SetEngineID("testString")
				getPrestissimoEngineCatalogOptionsModel.SetCatalogID("testString")
				getPrestissimoEngineCatalogOptionsModel.SetAuthInstanceID("testString")
				getPrestissimoEngineCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPrestissimoEngineCatalogOptionsModel).ToNot(BeNil())
				Expect(getPrestissimoEngineCatalogOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the GetPrestissimoEngineOptions model
				engineID := "testString"
				getPrestissimoEngineOptionsModel := watsonxDataService.NewGetPrestissimoEngineOptions(engineID)
				getPrestissimoEngineOptionsModel.SetEngineID("testString")
				getPrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				getPrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(getPrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPrestoEngineCatalogOptions successfully`, func() {
				// Construct an instance of the GetPrestoEngineCatalogOptions model
				engineID := "testString"
				catalogID := "testString"
				getPrestoEngineCatalogOptionsModel := watsonxDataService.NewGetPrestoEngineCatalogOptions(engineID, catalogID)
				getPrestoEngineCatalogOptionsModel.SetEngineID("testString")
				getPrestoEngineCatalogOptionsModel.SetCatalogID("testString")
				getPrestoEngineCatalogOptionsModel.SetAuthInstanceID("testString")
				getPrestoEngineCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPrestoEngineCatalogOptionsModel).ToNot(BeNil())
				Expect(getPrestoEngineCatalogOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetPrestoEngineOptions successfully`, func() {
				// Construct an instance of the GetPrestoEngineOptions model
				engineID := "testString"
				getPrestoEngineOptionsModel := watsonxDataService.NewGetPrestoEngineOptions(engineID)
				getPrestoEngineOptionsModel.SetEngineID("testString")
				getPrestoEngineOptionsModel.SetAuthInstanceID("testString")
				getPrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getPrestoEngineOptionsModel).ToNot(BeNil())
				Expect(getPrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getPrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSparkEngineApplicationStatusOptions successfully`, func() {
				// Construct an instance of the GetSparkEngineApplicationStatusOptions model
				engineID := "testString"
				applicationID := "testString"
				getSparkEngineApplicationStatusOptionsModel := watsonxDataService.NewGetSparkEngineApplicationStatusOptions(engineID, applicationID)
				getSparkEngineApplicationStatusOptionsModel.SetEngineID("testString")
				getSparkEngineApplicationStatusOptionsModel.SetApplicationID("testString")
				getSparkEngineApplicationStatusOptionsModel.SetAuthInstanceID("testString")
				getSparkEngineApplicationStatusOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSparkEngineApplicationStatusOptionsModel).ToNot(BeNil())
				Expect(getSparkEngineApplicationStatusOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineApplicationStatusOptionsModel.ApplicationID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineApplicationStatusOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineApplicationStatusOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSparkEngineCatalogOptions successfully`, func() {
				// Construct an instance of the GetSparkEngineCatalogOptions model
				engineID := "testString"
				catalogID := "testString"
				getSparkEngineCatalogOptionsModel := watsonxDataService.NewGetSparkEngineCatalogOptions(engineID, catalogID)
				getSparkEngineCatalogOptionsModel.SetEngineID("testString")
				getSparkEngineCatalogOptionsModel.SetCatalogID("testString")
				getSparkEngineCatalogOptionsModel.SetAuthInstanceID("testString")
				getSparkEngineCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSparkEngineCatalogOptionsModel).ToNot(BeNil())
				Expect(getSparkEngineCatalogOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSparkEngineHistoryServerOptions successfully`, func() {
				// Construct an instance of the GetSparkEngineHistoryServerOptions model
				engineID := "testString"
				getSparkEngineHistoryServerOptionsModel := watsonxDataService.NewGetSparkEngineHistoryServerOptions(engineID)
				getSparkEngineHistoryServerOptionsModel.SetEngineID("testString")
				getSparkEngineHistoryServerOptionsModel.SetAuthInstanceID("testString")
				getSparkEngineHistoryServerOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSparkEngineHistoryServerOptionsModel).ToNot(BeNil())
				Expect(getSparkEngineHistoryServerOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineHistoryServerOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineHistoryServerOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetSparkEngineOptions successfully`, func() {
				// Construct an instance of the GetSparkEngineOptions model
				engineID := "testString"
				getSparkEngineOptionsModel := watsonxDataService.NewGetSparkEngineOptions(engineID)
				getSparkEngineOptionsModel.SetEngineID("testString")
				getSparkEngineOptionsModel.SetAuthInstanceID("testString")
				getSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getSparkEngineOptionsModel).ToNot(BeNil())
				Expect(getSparkEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewGetTableOptions successfully`, func() {
				// Construct an instance of the GetTableOptions model
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				engineID := "testString"
				getTableOptionsModel := watsonxDataService.NewGetTableOptions(catalogID, schemaID, tableID, engineID)
				getTableOptionsModel.SetCatalogID("testString")
				getTableOptionsModel.SetSchemaID("testString")
				getTableOptionsModel.SetTableID("testString")
				getTableOptionsModel.SetEngineID("testString")
				getTableOptionsModel.SetAuthInstanceID("testString")
				getTableOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(getTableOptionsModel).ToNot(BeNil())
				Expect(getTableOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(getTableOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListBucketObjectsOptions successfully`, func() {
				// Construct an instance of the ListBucketObjectsOptions model
				bucketID := "testString"
				listBucketObjectsOptionsModel := watsonxDataService.NewListBucketObjectsOptions(bucketID)
				listBucketObjectsOptionsModel.SetBucketID("testString")
				listBucketObjectsOptionsModel.SetAuthInstanceID("testString")
				listBucketObjectsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listBucketObjectsOptionsModel).ToNot(BeNil())
				Expect(listBucketObjectsOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(listBucketObjectsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listBucketObjectsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListBucketRegistrationsOptions successfully`, func() {
				// Construct an instance of the ListBucketRegistrationsOptions model
				listBucketRegistrationsOptionsModel := watsonxDataService.NewListBucketRegistrationsOptions()
				listBucketRegistrationsOptionsModel.SetAuthInstanceID("testString")
				listBucketRegistrationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listBucketRegistrationsOptionsModel).ToNot(BeNil())
				Expect(listBucketRegistrationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listBucketRegistrationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListCatalogsOptions successfully`, func() {
				// Construct an instance of the ListCatalogsOptions model
				listCatalogsOptionsModel := watsonxDataService.NewListCatalogsOptions()
				listCatalogsOptionsModel.SetAuthInstanceID("testString")
				listCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listCatalogsOptionsModel).ToNot(BeNil())
				Expect(listCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListColumnsOptions successfully`, func() {
				// Construct an instance of the ListColumnsOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				listColumnsOptionsModel := watsonxDataService.NewListColumnsOptions(engineID, catalogID, schemaID, tableID)
				listColumnsOptionsModel.SetEngineID("testString")
				listColumnsOptionsModel.SetCatalogID("testString")
				listColumnsOptionsModel.SetSchemaID("testString")
				listColumnsOptionsModel.SetTableID("testString")
				listColumnsOptionsModel.SetAuthInstanceID("testString")
				listColumnsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listColumnsOptionsModel).ToNot(BeNil())
				Expect(listColumnsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listColumnsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListDatabaseRegistrationsOptions successfully`, func() {
				// Construct an instance of the ListDatabaseRegistrationsOptions model
				listDatabaseRegistrationsOptionsModel := watsonxDataService.NewListDatabaseRegistrationsOptions()
				listDatabaseRegistrationsOptionsModel.SetAuthInstanceID("testString")
				listDatabaseRegistrationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listDatabaseRegistrationsOptionsModel).ToNot(BeNil())
				Expect(listDatabaseRegistrationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listDatabaseRegistrationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListDb2EnginesOptions successfully`, func() {
				// Construct an instance of the ListDb2EnginesOptions model
				listDb2EnginesOptionsModel := watsonxDataService.NewListDb2EnginesOptions()
				listDb2EnginesOptionsModel.SetAuthInstanceID("testString")
				listDb2EnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listDb2EnginesOptionsModel).ToNot(BeNil())
				Expect(listDb2EnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listDb2EnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListIngestionJobsOptions successfully`, func() {
				// Construct an instance of the ListIngestionJobsOptions model
				authInstanceID := "testString"
				listIngestionJobsOptionsModel := watsonxDataService.NewListIngestionJobsOptions(authInstanceID)
				listIngestionJobsOptionsModel.SetAuthInstanceID("testString")
				listIngestionJobsOptionsModel.SetPage(int64(1))
				listIngestionJobsOptionsModel.SetJobsPerPage(int64(1))
				listIngestionJobsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listIngestionJobsOptionsModel).ToNot(BeNil())
				Expect(listIngestionJobsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listIngestionJobsOptionsModel.Page).To(Equal(core.Int64Ptr(int64(1))))
				Expect(listIngestionJobsOptionsModel.JobsPerPage).To(Equal(core.Int64Ptr(int64(1))))
				Expect(listIngestionJobsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListMilvusServicesOptions successfully`, func() {
				// Construct an instance of the ListMilvusServicesOptions model
				listMilvusServicesOptionsModel := watsonxDataService.NewListMilvusServicesOptions()
				listMilvusServicesOptionsModel.SetAuthInstanceID("testString")
				listMilvusServicesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listMilvusServicesOptionsModel).ToNot(BeNil())
				Expect(listMilvusServicesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listMilvusServicesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListNetezzaEnginesOptions successfully`, func() {
				// Construct an instance of the ListNetezzaEnginesOptions model
				listNetezzaEnginesOptionsModel := watsonxDataService.NewListNetezzaEnginesOptions()
				listNetezzaEnginesOptionsModel.SetAuthInstanceID("testString")
				listNetezzaEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listNetezzaEnginesOptionsModel).ToNot(BeNil())
				Expect(listNetezzaEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listNetezzaEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListOtherEnginesOptions successfully`, func() {
				// Construct an instance of the ListOtherEnginesOptions model
				listOtherEnginesOptionsModel := watsonxDataService.NewListOtherEnginesOptions()
				listOtherEnginesOptionsModel.SetAuthInstanceID("testString")
				listOtherEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listOtherEnginesOptionsModel).ToNot(BeNil())
				Expect(listOtherEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listOtherEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListPrestissimoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the ListPrestissimoEngineCatalogsOptions model
				engineID := "testString"
				listPrestissimoEngineCatalogsOptionsModel := watsonxDataService.NewListPrestissimoEngineCatalogsOptions(engineID)
				listPrestissimoEngineCatalogsOptionsModel.SetEngineID("testString")
				listPrestissimoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				listPrestissimoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listPrestissimoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(listPrestissimoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestissimoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestissimoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListPrestissimoEnginesOptions successfully`, func() {
				// Construct an instance of the ListPrestissimoEnginesOptions model
				listPrestissimoEnginesOptionsModel := watsonxDataService.NewListPrestissimoEnginesOptions()
				listPrestissimoEnginesOptionsModel.SetAuthInstanceID("testString")
				listPrestissimoEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listPrestissimoEnginesOptionsModel).ToNot(BeNil())
				Expect(listPrestissimoEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestissimoEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListPrestoEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the ListPrestoEngineCatalogsOptions model
				engineID := "testString"
				listPrestoEngineCatalogsOptionsModel := watsonxDataService.NewListPrestoEngineCatalogsOptions(engineID)
				listPrestoEngineCatalogsOptionsModel.SetEngineID("testString")
				listPrestoEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				listPrestoEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listPrestoEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(listPrestoEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestoEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestoEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListPrestoEnginesOptions successfully`, func() {
				// Construct an instance of the ListPrestoEnginesOptions model
				listPrestoEnginesOptionsModel := watsonxDataService.NewListPrestoEnginesOptions()
				listPrestoEnginesOptionsModel.SetAuthInstanceID("testString")
				listPrestoEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listPrestoEnginesOptionsModel).ToNot(BeNil())
				Expect(listPrestoEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listPrestoEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSchemasOptions successfully`, func() {
				// Construct an instance of the ListSchemasOptions model
				engineID := "testString"
				catalogID := "testString"
				listSchemasOptionsModel := watsonxDataService.NewListSchemasOptions(engineID, catalogID)
				listSchemasOptionsModel.SetEngineID("testString")
				listSchemasOptionsModel.SetCatalogID("testString")
				listSchemasOptionsModel.SetAuthInstanceID("testString")
				listSchemasOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSchemasOptionsModel).ToNot(BeNil())
				Expect(listSchemasOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listSchemasOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(listSchemasOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSchemasOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSparkEngineApplicationsOptions successfully`, func() {
				// Construct an instance of the ListSparkEngineApplicationsOptions model
				engineID := "testString"
				listSparkEngineApplicationsOptionsModel := watsonxDataService.NewListSparkEngineApplicationsOptions(engineID)
				listSparkEngineApplicationsOptionsModel.SetEngineID("testString")
				listSparkEngineApplicationsOptionsModel.SetAuthInstanceID("testString")
				listSparkEngineApplicationsOptionsModel.SetState([]string{"testString"})
				listSparkEngineApplicationsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSparkEngineApplicationsOptionsModel).ToNot(BeNil())
				Expect(listSparkEngineApplicationsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEngineApplicationsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEngineApplicationsOptionsModel.State).To(Equal([]string{"testString"}))
				Expect(listSparkEngineApplicationsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSparkEngineCatalogsOptions successfully`, func() {
				// Construct an instance of the ListSparkEngineCatalogsOptions model
				engineID := "testString"
				listSparkEngineCatalogsOptionsModel := watsonxDataService.NewListSparkEngineCatalogsOptions(engineID)
				listSparkEngineCatalogsOptionsModel.SetEngineID("testString")
				listSparkEngineCatalogsOptionsModel.SetAuthInstanceID("testString")
				listSparkEngineCatalogsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSparkEngineCatalogsOptionsModel).ToNot(BeNil())
				Expect(listSparkEngineCatalogsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEngineCatalogsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEngineCatalogsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSparkEnginesOptions successfully`, func() {
				// Construct an instance of the ListSparkEnginesOptions model
				listSparkEnginesOptionsModel := watsonxDataService.NewListSparkEnginesOptions()
				listSparkEnginesOptionsModel.SetAuthInstanceID("testString")
				listSparkEnginesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSparkEnginesOptionsModel).ToNot(BeNil())
				Expect(listSparkEnginesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkEnginesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListSparkVersionsOptions successfully`, func() {
				// Construct an instance of the ListSparkVersionsOptions model
				listSparkVersionsOptionsModel := watsonxDataService.NewListSparkVersionsOptions()
				listSparkVersionsOptionsModel.SetAuthInstanceID("testString")
				listSparkVersionsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listSparkVersionsOptionsModel).ToNot(BeNil())
				Expect(listSparkVersionsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listSparkVersionsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListTableSnapshotsOptions successfully`, func() {
				// Construct an instance of the ListTableSnapshotsOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				listTableSnapshotsOptionsModel := watsonxDataService.NewListTableSnapshotsOptions(engineID, catalogID, schemaID, tableID)
				listTableSnapshotsOptionsModel.SetEngineID("testString")
				listTableSnapshotsOptionsModel.SetCatalogID("testString")
				listTableSnapshotsOptionsModel.SetSchemaID("testString")
				listTableSnapshotsOptionsModel.SetTableID("testString")
				listTableSnapshotsOptionsModel.SetAuthInstanceID("testString")
				listTableSnapshotsOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listTableSnapshotsOptionsModel).ToNot(BeNil())
				Expect(listTableSnapshotsOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listTableSnapshotsOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewListTablesOptions successfully`, func() {
				// Construct an instance of the ListTablesOptions model
				catalogID := "testString"
				schemaID := "testString"
				engineID := "testString"
				listTablesOptionsModel := watsonxDataService.NewListTablesOptions(catalogID, schemaID, engineID)
				listTablesOptionsModel.SetCatalogID("testString")
				listTablesOptionsModel.SetSchemaID("testString")
				listTablesOptionsModel.SetEngineID("testString")
				listTablesOptionsModel.SetAuthInstanceID("testString")
				listTablesOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(listTablesOptionsModel).ToNot(BeNil())
				Expect(listTablesOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(listTablesOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(listTablesOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(listTablesOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(listTablesOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewOtherEngineDetailsBody successfully`, func() {
				connectionString := "1.2.3.4"
				engineType := "netezza"
				_model, err := watsonxDataService.NewOtherEngineDetailsBody(connectionString, engineType)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewPausePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the PausePrestissimoEngineOptions model
				engineID := "testString"
				pausePrestissimoEngineOptionsModel := watsonxDataService.NewPausePrestissimoEngineOptions(engineID)
				pausePrestissimoEngineOptionsModel.SetEngineID("testString")
				pausePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				pausePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(pausePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(pausePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(pausePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(pausePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewPausePrestoEngineOptions successfully`, func() {
				// Construct an instance of the PausePrestoEngineOptions model
				engineID := "testString"
				pausePrestoEngineOptionsModel := watsonxDataService.NewPausePrestoEngineOptions(engineID)
				pausePrestoEngineOptionsModel.SetEngineID("testString")
				pausePrestoEngineOptionsModel.SetAuthInstanceID("testString")
				pausePrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(pausePrestoEngineOptionsModel).ToNot(BeNil())
				Expect(pausePrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(pausePrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(pausePrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRenameTableOptions successfully`, func() {
				// Construct an instance of the RenameTableOptions model
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				renameTableOptionsModel := watsonxDataService.NewRenameTableOptions(catalogID, schemaID, tableID, engineID, body)
				renameTableOptionsModel.SetCatalogID("testString")
				renameTableOptionsModel.SetSchemaID("testString")
				renameTableOptionsModel.SetTableID("testString")
				renameTableOptionsModel.SetEngineID("testString")
				renameTableOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				renameTableOptionsModel.SetAuthInstanceID("testString")
				renameTableOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(renameTableOptionsModel).ToNot(BeNil())
				Expect(renameTableOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(renameTableOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(renameTableOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(renameTableOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(renameTableOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(renameTableOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(renameTableOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRestartPrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the RestartPrestissimoEngineOptions model
				engineID := "testString"
				restartPrestissimoEngineOptionsModel := watsonxDataService.NewRestartPrestissimoEngineOptions(engineID)
				restartPrestissimoEngineOptionsModel.SetEngineID("testString")
				restartPrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				restartPrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(restartPrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(restartPrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(restartPrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(restartPrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRestartPrestoEngineOptions successfully`, func() {
				// Construct an instance of the RestartPrestoEngineOptions model
				engineID := "testString"
				restartPrestoEngineOptionsModel := watsonxDataService.NewRestartPrestoEngineOptions(engineID)
				restartPrestoEngineOptionsModel.SetEngineID("testString")
				restartPrestoEngineOptionsModel.SetAuthInstanceID("testString")
				restartPrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(restartPrestoEngineOptionsModel).ToNot(BeNil())
				Expect(restartPrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(restartPrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(restartPrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewResumePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the ResumePrestissimoEngineOptions model
				engineID := "testString"
				resumePrestissimoEngineOptionsModel := watsonxDataService.NewResumePrestissimoEngineOptions(engineID)
				resumePrestissimoEngineOptionsModel.SetEngineID("testString")
				resumePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				resumePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(resumePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(resumePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(resumePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(resumePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewResumePrestoEngineOptions successfully`, func() {
				// Construct an instance of the ResumePrestoEngineOptions model
				engineID := "testString"
				resumePrestoEngineOptionsModel := watsonxDataService.NewResumePrestoEngineOptions(engineID)
				resumePrestoEngineOptionsModel.SetEngineID("testString")
				resumePrestoEngineOptionsModel.SetAuthInstanceID("testString")
				resumePrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(resumePrestoEngineOptionsModel).ToNot(BeNil())
				Expect(resumePrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(resumePrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(resumePrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRollbackTableOptions successfully`, func() {
				// Construct an instance of the RollbackTableOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				rollbackTableOptionsModel := watsonxDataService.NewRollbackTableOptions(engineID, catalogID, schemaID, tableID)
				rollbackTableOptionsModel.SetEngineID("testString")
				rollbackTableOptionsModel.SetCatalogID("testString")
				rollbackTableOptionsModel.SetSchemaID("testString")
				rollbackTableOptionsModel.SetTableID("testString")
				rollbackTableOptionsModel.SetSnapshotID("testString")
				rollbackTableOptionsModel.SetAuthInstanceID("testString")
				rollbackTableOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(rollbackTableOptionsModel).ToNot(BeNil())
				Expect(rollbackTableOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.SnapshotID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(rollbackTableOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRunExplainAnalyzeStatementOptions successfully`, func() {
				// Construct an instance of the RunExplainAnalyzeStatementOptions model
				engineID := "testString"
				runExplainAnalyzeStatementOptionsStatement := "show schemas in catalog_name"
				runExplainAnalyzeStatementOptionsModel := watsonxDataService.NewRunExplainAnalyzeStatementOptions(engineID, runExplainAnalyzeStatementOptionsStatement)
				runExplainAnalyzeStatementOptionsModel.SetEngineID("testString")
				runExplainAnalyzeStatementOptionsModel.SetStatement("show schemas in catalog_name")
				runExplainAnalyzeStatementOptionsModel.SetVerbose(true)
				runExplainAnalyzeStatementOptionsModel.SetAuthInstanceID("testString")
				runExplainAnalyzeStatementOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(runExplainAnalyzeStatementOptionsModel).ToNot(BeNil())
				Expect(runExplainAnalyzeStatementOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(runExplainAnalyzeStatementOptionsModel.Statement).To(Equal(core.StringPtr("show schemas in catalog_name")))
				Expect(runExplainAnalyzeStatementOptionsModel.Verbose).To(Equal(core.BoolPtr(true)))
				Expect(runExplainAnalyzeStatementOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(runExplainAnalyzeStatementOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRunExplainStatementOptions successfully`, func() {
				// Construct an instance of the RunExplainStatementOptions model
				engineID := "testString"
				runExplainStatementOptionsStatement := "show schemas in catalog_name"
				runExplainStatementOptionsModel := watsonxDataService.NewRunExplainStatementOptions(engineID, runExplainStatementOptionsStatement)
				runExplainStatementOptionsModel.SetEngineID("testString")
				runExplainStatementOptionsModel.SetStatement("show schemas in catalog_name")
				runExplainStatementOptionsModel.SetFormat("json")
				runExplainStatementOptionsModel.SetType("io")
				runExplainStatementOptionsModel.SetAuthInstanceID("testString")
				runExplainStatementOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(runExplainStatementOptionsModel).ToNot(BeNil())
				Expect(runExplainStatementOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(runExplainStatementOptionsModel.Statement).To(Equal(core.StringPtr("show schemas in catalog_name")))
				Expect(runExplainStatementOptionsModel.Format).To(Equal(core.StringPtr("json")))
				Expect(runExplainStatementOptionsModel.Type).To(Equal(core.StringPtr("io")))
				Expect(runExplainStatementOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(runExplainStatementOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRunPrestissimoExplainAnalyzeStatementOptions successfully`, func() {
				// Construct an instance of the RunPrestissimoExplainAnalyzeStatementOptions model
				engineID := "testString"
				runPrestissimoExplainAnalyzeStatementOptionsStatement := "show schemas in catalog_name"
				runPrestissimoExplainAnalyzeStatementOptionsModel := watsonxDataService.NewRunPrestissimoExplainAnalyzeStatementOptions(engineID, runPrestissimoExplainAnalyzeStatementOptionsStatement)
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetEngineID("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetStatement("show schemas in catalog_name")
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetVerbose(true)
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetAuthInstanceID("testString")
				runPrestissimoExplainAnalyzeStatementOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel).ToNot(BeNil())
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.Statement).To(Equal(core.StringPtr("show schemas in catalog_name")))
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.Verbose).To(Equal(core.BoolPtr(true)))
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(runPrestissimoExplainAnalyzeStatementOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewRunPrestissimoExplainStatementOptions successfully`, func() {
				// Construct an instance of the RunPrestissimoExplainStatementOptions model
				engineID := "testString"
				runPrestissimoExplainStatementOptionsStatement := "show schemas in catalog_name"
				runPrestissimoExplainStatementOptionsModel := watsonxDataService.NewRunPrestissimoExplainStatementOptions(engineID, runPrestissimoExplainStatementOptionsStatement)
				runPrestissimoExplainStatementOptionsModel.SetEngineID("testString")
				runPrestissimoExplainStatementOptionsModel.SetStatement("show schemas in catalog_name")
				runPrestissimoExplainStatementOptionsModel.SetFormat("json")
				runPrestissimoExplainStatementOptionsModel.SetType("io")
				runPrestissimoExplainStatementOptionsModel.SetAuthInstanceID("testString")
				runPrestissimoExplainStatementOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(runPrestissimoExplainStatementOptionsModel).ToNot(BeNil())
				Expect(runPrestissimoExplainStatementOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(runPrestissimoExplainStatementOptionsModel.Statement).To(Equal(core.StringPtr("show schemas in catalog_name")))
				Expect(runPrestissimoExplainStatementOptionsModel.Format).To(Equal(core.StringPtr("json")))
				Expect(runPrestissimoExplainStatementOptionsModel.Type).To(Equal(core.StringPtr("io")))
				Expect(runPrestissimoExplainStatementOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(runPrestissimoExplainStatementOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewScalePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the PrestissimoNodeDescriptionBody model
				prestissimoNodeDescriptionBodyModel := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
				Expect(prestissimoNodeDescriptionBodyModel).ToNot(BeNil())
				prestissimoNodeDescriptionBodyModel.NodeType = core.StringPtr("worker")
				prestissimoNodeDescriptionBodyModel.Quantity = core.Int64Ptr(int64(38))
				Expect(prestissimoNodeDescriptionBodyModel.NodeType).To(Equal(core.StringPtr("worker")))
				Expect(prestissimoNodeDescriptionBodyModel.Quantity).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ScalePrestissimoEngineOptions model
				engineID := "testString"
				scalePrestissimoEngineOptionsModel := watsonxDataService.NewScalePrestissimoEngineOptions(engineID)
				scalePrestissimoEngineOptionsModel.SetEngineID("testString")
				scalePrestissimoEngineOptionsModel.SetCoordinator(prestissimoNodeDescriptionBodyModel)
				scalePrestissimoEngineOptionsModel.SetWorker(prestissimoNodeDescriptionBodyModel)
				scalePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				scalePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(scalePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(scalePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(scalePrestissimoEngineOptionsModel.Coordinator).To(Equal(prestissimoNodeDescriptionBodyModel))
				Expect(scalePrestissimoEngineOptionsModel.Worker).To(Equal(prestissimoNodeDescriptionBodyModel))
				Expect(scalePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(scalePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewScalePrestoEngineOptions successfully`, func() {
				// Construct an instance of the NodeDescription model
				nodeDescriptionModel := new(watsonxdatav2.NodeDescription)
				Expect(nodeDescriptionModel).ToNot(BeNil())
				nodeDescriptionModel.NodeType = core.StringPtr("worker")
				nodeDescriptionModel.Quantity = core.Int64Ptr(int64(38))
				Expect(nodeDescriptionModel.NodeType).To(Equal(core.StringPtr("worker")))
				Expect(nodeDescriptionModel.Quantity).To(Equal(core.Int64Ptr(int64(38))))

				// Construct an instance of the ScalePrestoEngineOptions model
				engineID := "testString"
				scalePrestoEngineOptionsModel := watsonxDataService.NewScalePrestoEngineOptions(engineID)
				scalePrestoEngineOptionsModel.SetEngineID("testString")
				scalePrestoEngineOptionsModel.SetCoordinator(nodeDescriptionModel)
				scalePrestoEngineOptionsModel.SetWorker(nodeDescriptionModel)
				scalePrestoEngineOptionsModel.SetAuthInstanceID("testString")
				scalePrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(scalePrestoEngineOptionsModel).ToNot(BeNil())
				Expect(scalePrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(scalePrestoEngineOptionsModel.Coordinator).To(Equal(nodeDescriptionModel))
				Expect(scalePrestoEngineOptionsModel.Worker).To(Equal(nodeDescriptionModel))
				Expect(scalePrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(scalePrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewStartSparkEngineHistoryServerOptions successfully`, func() {
				// Construct an instance of the StartSparkEngineHistoryServerOptions model
				engineID := "testString"
				startSparkEngineHistoryServerOptionsModel := watsonxDataService.NewStartSparkEngineHistoryServerOptions(engineID)
				startSparkEngineHistoryServerOptionsModel.SetEngineID("testString")
				startSparkEngineHistoryServerOptionsModel.SetCores("1")
				startSparkEngineHistoryServerOptionsModel.SetMemory("4G")
				startSparkEngineHistoryServerOptionsModel.SetAuthInstanceID("testString")
				startSparkEngineHistoryServerOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(startSparkEngineHistoryServerOptionsModel).ToNot(BeNil())
				Expect(startSparkEngineHistoryServerOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(startSparkEngineHistoryServerOptionsModel.Cores).To(Equal(core.StringPtr("1")))
				Expect(startSparkEngineHistoryServerOptionsModel.Memory).To(Equal(core.StringPtr("4G")))
				Expect(startSparkEngineHistoryServerOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(startSparkEngineHistoryServerOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewSyncCatalogs successfully`, func() {
				autoAddNewTables := true
				syncIcebergMd := true
				_model, err := watsonxDataService.NewSyncCatalogs(autoAddNewTables, syncIcebergMd)
				Expect(_model).ToNot(BeNil())
				Expect(err).To(BeNil())
			})
			It(`Invoke NewUpdateBucketRegistrationOptions successfully`, func() {
				// Construct an instance of the UpdateBucketRegistrationOptions model
				bucketID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateBucketRegistrationOptionsModel := watsonxDataService.NewUpdateBucketRegistrationOptions(bucketID, body)
				updateBucketRegistrationOptionsModel.SetBucketID("testString")
				updateBucketRegistrationOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateBucketRegistrationOptionsModel.SetAuthInstanceID("testString")
				updateBucketRegistrationOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateBucketRegistrationOptionsModel).ToNot(BeNil())
				Expect(updateBucketRegistrationOptionsModel.BucketID).To(Equal(core.StringPtr("testString")))
				Expect(updateBucketRegistrationOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateBucketRegistrationOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateBucketRegistrationOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateColumnOptions successfully`, func() {
				// Construct an instance of the UpdateColumnOptions model
				engineID := "testString"
				catalogID := "testString"
				schemaID := "testString"
				tableID := "testString"
				columnID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateColumnOptionsModel := watsonxDataService.NewUpdateColumnOptions(engineID, catalogID, schemaID, tableID, columnID, body)
				updateColumnOptionsModel.SetEngineID("testString")
				updateColumnOptionsModel.SetCatalogID("testString")
				updateColumnOptionsModel.SetSchemaID("testString")
				updateColumnOptionsModel.SetTableID("testString")
				updateColumnOptionsModel.SetColumnID("testString")
				updateColumnOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateColumnOptionsModel.SetAuthInstanceID("testString")
				updateColumnOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateColumnOptionsModel).ToNot(BeNil())
				Expect(updateColumnOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.SchemaID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.TableID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.ColumnID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateColumnOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateColumnOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateDatabaseOptions successfully`, func() {
				// Construct an instance of the UpdateDatabaseOptions model
				databaseID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateDatabaseOptionsModel := watsonxDataService.NewUpdateDatabaseOptions(databaseID, body)
				updateDatabaseOptionsModel.SetDatabaseID("testString")
				updateDatabaseOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateDatabaseOptionsModel.SetAuthInstanceID("testString")
				updateDatabaseOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateDatabaseOptionsModel).ToNot(BeNil())
				Expect(updateDatabaseOptionsModel.DatabaseID).To(Equal(core.StringPtr("testString")))
				Expect(updateDatabaseOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateDatabaseOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateDatabaseOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateDb2EngineOptions successfully`, func() {
				// Construct an instance of the UpdateDb2EngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateDb2EngineOptionsModel := watsonxDataService.NewUpdateDb2EngineOptions(engineID, body)
				updateDb2EngineOptionsModel.SetEngineID("testString")
				updateDb2EngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateDb2EngineOptionsModel.SetAuthInstanceID("testString")
				updateDb2EngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateDb2EngineOptionsModel).ToNot(BeNil())
				Expect(updateDb2EngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updateDb2EngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateDb2EngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateDb2EngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateMilvusServiceOptions successfully`, func() {
				// Construct an instance of the UpdateMilvusServiceOptions model
				serviceID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateMilvusServiceOptionsModel := watsonxDataService.NewUpdateMilvusServiceOptions(serviceID, body)
				updateMilvusServiceOptionsModel.SetServiceID("testString")
				updateMilvusServiceOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateMilvusServiceOptionsModel.SetAuthInstanceID("testString")
				updateMilvusServiceOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateMilvusServiceOptionsModel).ToNot(BeNil())
				Expect(updateMilvusServiceOptionsModel.ServiceID).To(Equal(core.StringPtr("testString")))
				Expect(updateMilvusServiceOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateMilvusServiceOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateMilvusServiceOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateNetezzaEngineOptions successfully`, func() {
				// Construct an instance of the UpdateNetezzaEngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateNetezzaEngineOptionsModel := watsonxDataService.NewUpdateNetezzaEngineOptions(engineID, body)
				updateNetezzaEngineOptionsModel.SetEngineID("testString")
				updateNetezzaEngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateNetezzaEngineOptionsModel.SetAuthInstanceID("testString")
				updateNetezzaEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateNetezzaEngineOptionsModel).ToNot(BeNil())
				Expect(updateNetezzaEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updateNetezzaEngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateNetezzaEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateNetezzaEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdatePrestissimoEngineOptions successfully`, func() {
				// Construct an instance of the UpdatePrestissimoEngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updatePrestissimoEngineOptionsModel := watsonxDataService.NewUpdatePrestissimoEngineOptions(engineID, body)
				updatePrestissimoEngineOptionsModel.SetEngineID("testString")
				updatePrestissimoEngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updatePrestissimoEngineOptionsModel.SetAuthInstanceID("testString")
				updatePrestissimoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updatePrestissimoEngineOptionsModel).ToNot(BeNil())
				Expect(updatePrestissimoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updatePrestissimoEngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updatePrestissimoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updatePrestissimoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdatePrestoEngineOptions successfully`, func() {
				// Construct an instance of the UpdatePrestoEngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updatePrestoEngineOptionsModel := watsonxDataService.NewUpdatePrestoEngineOptions(engineID, body)
				updatePrestoEngineOptionsModel.SetEngineID("testString")
				updatePrestoEngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updatePrestoEngineOptionsModel.SetAuthInstanceID("testString")
				updatePrestoEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updatePrestoEngineOptionsModel).ToNot(BeNil())
				Expect(updatePrestoEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updatePrestoEngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updatePrestoEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updatePrestoEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateSparkEngineOptions successfully`, func() {
				// Construct an instance of the UpdateSparkEngineOptions model
				engineID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateSparkEngineOptionsModel := watsonxDataService.NewUpdateSparkEngineOptions(engineID, body)
				updateSparkEngineOptionsModel.SetEngineID("testString")
				updateSparkEngineOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateSparkEngineOptionsModel.SetAuthInstanceID("testString")
				updateSparkEngineOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateSparkEngineOptionsModel).ToNot(BeNil())
				Expect(updateSparkEngineOptionsModel.EngineID).To(Equal(core.StringPtr("testString")))
				Expect(updateSparkEngineOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateSparkEngineOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateSparkEngineOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
			It(`Invoke NewUpdateSyncCatalogOptions successfully`, func() {
				// Construct an instance of the UpdateSyncCatalogOptions model
				catalogID := "testString"
				body := map[string]interface{}{"anyKey": "anyValue"}
				updateSyncCatalogOptionsModel := watsonxDataService.NewUpdateSyncCatalogOptions(catalogID, body)
				updateSyncCatalogOptionsModel.SetCatalogID("testString")
				updateSyncCatalogOptionsModel.SetBody(map[string]interface{}{"anyKey": "anyValue"})
				updateSyncCatalogOptionsModel.SetAuthInstanceID("testString")
				updateSyncCatalogOptionsModel.SetHeaders(map[string]string{"foo": "bar"})
				Expect(updateSyncCatalogOptionsModel).ToNot(BeNil())
				Expect(updateSyncCatalogOptionsModel.CatalogID).To(Equal(core.StringPtr("testString")))
				Expect(updateSyncCatalogOptionsModel.Body).To(Equal(map[string]interface{}{"anyKey": "anyValue"}))
				Expect(updateSyncCatalogOptionsModel.AuthInstanceID).To(Equal(core.StringPtr("testString")))
				Expect(updateSyncCatalogOptionsModel.Headers).To(Equal(map[string]string{"foo": "bar"}))
			})
		})
	})
	Describe(`Model unmarshaling tests`, func() {
		It(`Invoke UnmarshalBucketCatalog successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.BucketCatalog)
			model.CatalogName = core.StringPtr("sampleCatalog")
			model.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
			model.CatalogType = core.StringPtr("iceberg")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.BucketCatalog
			err = watsonxdatav2.UnmarshalBucketCatalog(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalBucketDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.BucketDetails)
			model.AccessKey = core.StringPtr("b9cbf248ea5c4c96947e64407108559j")
			model.BucketName = core.StringPtr("sample-bucket")
			model.Endpoint = core.StringPtr("https://s3.<region>.cloud-object-storage.appdomain.cloud/")
			model.SecretKey = core.StringPtr("13b4045cac1a0be54c9fjbe53cb22df5fn397cd2c45b66c87")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.BucketDetails
			err = watsonxdatav2.UnmarshalBucketDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalBucketRegistrationPatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.BucketRegistrationPatch)
			model.BucketDetails = nil
			model.BucketDisplayName = core.StringPtr("sample-bucket-displayname")
			model.Description = core.StringPtr("COS bucket for customer data")
			model.Tags = []string{"testbucket", "userbucket"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.BucketRegistrationPatch
			err = watsonxdatav2.UnmarshalBucketRegistrationPatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalColumn successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.Column)
			model.ColumnName = core.StringPtr("expenses")
			model.Comment = core.StringPtr("expenses column")
			model.Extra = core.StringPtr("varchar")
			model.Length = core.StringPtr("30")
			model.Scale = core.StringPtr("2")
			model.Type = core.StringPtr("varchar")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.Column
			err = watsonxdatav2.UnmarshalColumn(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalColumnPatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.ColumnPatch)
			model.ColumnName = core.StringPtr("expenses")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.ColumnPatch
			err = watsonxdatav2.UnmarshalColumnPatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseCatalog successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseCatalog)
			model.CatalogName = core.StringPtr("sampleCatalog")
			model.CatalogTags = []string{"catalog_tag_1", "catalog_tag_2"}
			model.CatalogType = core.StringPtr("iceberg")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseCatalog
			err = watsonxdatav2.UnmarshalDatabaseCatalog(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseDetails)
			model.Certificate = core.StringPtr("contents of a pem/crt file")
			model.CertificateExtension = core.StringPtr("pem/crt")
			model.DatabaseName = core.StringPtr("new_database")
			model.Hostname = core.StringPtr("db2@<hostname>.com")
			model.HostnameInCertificate = core.StringPtr("samplehostname")
			model.Hosts = core.StringPtr("abc.com:1234,xyz.com:4321")
			model.Password = core.StringPtr("samplepassword")
			model.Port = core.Int64Ptr(int64(4553))
			model.Sasl = core.BoolPtr(true)
			model.Ssl = core.BoolPtr(true)
			model.Tables = core.StringPtr("kafka_table_name")
			model.Username = core.StringPtr("sampleuser")
			model.ValidateServerCertificate = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseDetails
			err = watsonxdatav2.UnmarshalDatabaseDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseRegistrationPatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseRegistrationPatch)
			model.DatabaseDetails = nil
			model.DatabaseDisplayName = core.StringPtr("new_database")
			model.Description = core.StringPtr("External database description")
			model.Tags = []string{"testdatabase", "userdatabase"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseRegistrationPatch
			err = watsonxdatav2.UnmarshalDatabaseRegistrationPatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseRegistrationPatchDatabaseDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails)
			model.Password = core.StringPtr("samplepassword")
			model.Username = core.StringPtr("sampleuser")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseRegistrationPatchDatabaseDetails
			err = watsonxdatav2.UnmarshalDatabaseRegistrationPatchDatabaseDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDatabaseRegistrationPrototypeDatabasePropertiesItems successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems)
			model.Encrypt = core.BoolPtr(true)
			model.Key = core.StringPtr("hive.metastore")
			model.Value = core.StringPtr("glue")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.DatabaseRegistrationPrototypeDatabasePropertiesItems
			err = watsonxdatav2.UnmarshalDatabaseRegistrationPrototypeDatabasePropertiesItems(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDb2EngineDetailsBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.Db2EngineDetailsBody)
			model.ConnectionString = core.StringPtr("1.2.3.4")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.Db2EngineDetailsBody
			err = watsonxdatav2.UnmarshalDb2EngineDetailsBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalDb2EnginePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.Db2EnginePatch)
			model.Description = core.StringPtr("db2 engine updated description")
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.Db2EnginePatch
			err = watsonxdatav2.UnmarshalDb2EnginePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEngineDetailsBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EngineDetailsBody)
			model.ApiKey = core.StringPtr("<api_key>")
			model.ConnectionString = core.StringPtr("1.2.3.4")
			model.Coordinator = nil
			model.InstanceID = core.StringPtr("instance_id")
			model.ManagedBy = core.StringPtr("fully/self")
			model.SizeConfig = core.StringPtr("starter")
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EngineDetailsBody
			err = watsonxdatav2.UnmarshalEngineDetailsBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEnginePropertiesOaiGen1Configuration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EnginePropertiesOaiGen1Configuration)
			model.Coordinator = nil
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EnginePropertiesOaiGen1Configuration
			err = watsonxdatav2.UnmarshalEnginePropertiesOaiGen1Configuration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEnginePropertiesOaiGen1Jvm successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EnginePropertiesOaiGen1Jvm)
			model.Coordinator = nil
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EnginePropertiesOaiGen1Jvm
			err = watsonxdatav2.UnmarshalEnginePropertiesOaiGen1Jvm(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalEnginePropertiesOaiGenConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.EnginePropertiesOaiGenConfiguration)
			model.Coordinator = nil
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.EnginePropertiesOaiGenConfiguration
			err = watsonxdatav2.UnmarshalEnginePropertiesOaiGenConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalIngestionJobPrototypeCsvProperty successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.IngestionJobPrototypeCsvProperty)
			model.Encoding = core.StringPtr("utf-8")
			model.EscapeCharacter = core.StringPtr("\\\\")
			model.FieldDelimiter = core.StringPtr(",")
			model.Header = core.BoolPtr(true)
			model.LineDelimiter = core.StringPtr("\\n")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.IngestionJobPrototypeCsvProperty
			err = watsonxdatav2.UnmarshalIngestionJobPrototypeCsvProperty(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalIngestionJobPrototypeExecuteConfig successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.IngestionJobPrototypeExecuteConfig)
			model.DriverCores = core.Int64Ptr(int64(1))
			model.DriverMemory = core.StringPtr("2G")
			model.ExecutorCores = core.Int64Ptr(int64(1))
			model.ExecutorMemory = core.StringPtr("2G")
			model.NumExecutors = core.Int64Ptr(int64(1))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.IngestionJobPrototypeExecuteConfig
			err = watsonxdatav2.UnmarshalIngestionJobPrototypeExecuteConfig(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalMilvusServicePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.MilvusServicePatch)
			model.Description = core.StringPtr("updated description for milvus service")
			model.ServiceDisplayName = core.StringPtr("sampleService")
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.MilvusServicePatch
			err = watsonxdatav2.UnmarshalMilvusServicePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalNetezzaEngineDetailsBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.NetezzaEngineDetailsBody)
			model.ConnectionString = core.StringPtr("1.2.3.4")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.NetezzaEngineDetailsBody
			err = watsonxdatav2.UnmarshalNetezzaEngineDetailsBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalNetezzaEnginePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.NetezzaEnginePatch)
			model.Description = core.StringPtr("netezza engine updated description")
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.NetezzaEnginePatch
			err = watsonxdatav2.UnmarshalNetezzaEnginePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalNodeDescription successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.NodeDescription)
			model.NodeType = core.StringPtr("worker")
			model.Quantity = core.Int64Ptr(int64(38))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.NodeDescription
			err = watsonxdatav2.UnmarshalNodeDescription(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalNodeDescriptionBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.NodeDescriptionBody)
			model.NodeType = core.StringPtr("worker")
			model.Quantity = core.Int64Ptr(int64(38))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.NodeDescriptionBody
			err = watsonxdatav2.UnmarshalNodeDescriptionBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalOtherEngineDetailsBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.OtherEngineDetailsBody)
			model.ConnectionString = core.StringPtr("1.2.3.4")
			model.EngineType = core.StringPtr("netezza")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.OtherEngineDetailsBody
			err = watsonxdatav2.UnmarshalOtherEngineDetailsBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEndpoints successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEndpoints)
			model.ApplicationsApi = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications/<application_id>")
			model.HistoryServerEndpoint = core.StringPtr("$HOST/v2/spark/v3/instances/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_history_server")
			model.SparkAccessEndpoint = core.StringPtr("$HOST/analytics-engine/details/spark-<instance_id>")
			model.SparkJobsV4Endpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/spark_applications")
			model.SparkKernelEndpoint = core.StringPtr("$HOST/v4/analytics_engines/c7b3fccf-badb-46b0-b1ef-9b3154424021/jkg/api/kernels")
			model.ViewHistoryServer = core.StringPtr("testString")
			model.WxdApplicationEndpoint = core.StringPtr("$HOST/v1/1698311655308796/engines/spark817/applications")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEndpoints
			err = watsonxdatav2.UnmarshalPrestissimoEndpoints(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEngineDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEngineDetails)
			model.ApiKey = core.StringPtr("<api_key>")
			model.ConnectionString = core.StringPtr("1.2.3.4")
			model.Coordinator = nil
			model.Endpoints = nil
			model.InstanceID = core.StringPtr("instance_id")
			model.ManagedBy = core.StringPtr("fully/self")
			model.MetastoreHost = core.StringPtr("1.2.3.4")
			model.SizeConfig = core.StringPtr("starter")
			model.Worker = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEngineDetails
			err = watsonxdatav2.UnmarshalPrestissimoEngineDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEngineEngineProperties successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEngineEngineProperties)
			model.Catalog = nil
			model.Configuration = nil
			model.Velox = nil
			model.Jvm = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEngineEngineProperties
			err = watsonxdatav2.UnmarshalPrestissimoEngineEngineProperties(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEnginePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEnginePatch)
			model.Description = core.StringPtr("updated description for prestissimo engine")
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.EngineProperties = nil
			model.EngineRestart = core.StringPtr("force")
			model.RemoveEngineProperties = nil
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEnginePatch
			err = watsonxdatav2.UnmarshalPrestissimoEnginePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEnginePropertiesCatalog successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEnginePropertiesCatalog)
			model.CatalogName = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEnginePropertiesCatalog
			err = watsonxdatav2.UnmarshalPrestissimoEnginePropertiesCatalog(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEnginePropertiesOaiGen1Jvm successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm)
			model.Coordinator = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEnginePropertiesOaiGen1Jvm
			err = watsonxdatav2.UnmarshalPrestissimoEnginePropertiesOaiGen1Jvm(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoEnginePropertiesVelox successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoEnginePropertiesVelox)
			model.VeloxProperty = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoEnginePropertiesVelox
			err = watsonxdatav2.UnmarshalPrestissimoEnginePropertiesVelox(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestissimoNodeDescriptionBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestissimoNodeDescriptionBody)
			model.NodeType = core.StringPtr("worker")
			model.Quantity = core.Int64Ptr(int64(38))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestissimoNodeDescriptionBody
			err = watsonxdatav2.UnmarshalPrestissimoNodeDescriptionBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEngineEngineProperties successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEngineEngineProperties)
			model.Catalog = nil
			model.Configuration = nil
			model.Global = nil
			model.Jvm = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEngineEngineProperties
			err = watsonxdatav2.UnmarshalPrestoEngineEngineProperties(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEnginePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEnginePatch)
			model.Description = core.StringPtr("updated description for presto engine")
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.EngineProperties = nil
			model.EngineRestart = core.StringPtr("force")
			model.RemoveEngineProperties = nil
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEnginePatch
			err = watsonxdatav2.UnmarshalPrestoEnginePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEnginePatchRemoveEngineProperties successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEnginePatchRemoveEngineProperties)
			model.Configuration = nil
			model.Jvm = nil
			model.Catalog = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEnginePatchRemoveEngineProperties
			err = watsonxdatav2.UnmarshalPrestoEnginePatchRemoveEngineProperties(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEnginePropertiesCatalog successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEnginePropertiesCatalog)
			model.CatalogName = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEnginePropertiesCatalog
			err = watsonxdatav2.UnmarshalPrestoEnginePropertiesCatalog(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPrestoEnginePropertiesGlobal successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PrestoEnginePropertiesGlobal)
			model.GlobalProperty = core.StringPtr("enable-mixed-case-support:true")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PrestoEnginePropertiesGlobal
			err = watsonxdatav2.UnmarshalPrestoEnginePropertiesGlobal(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalPreviewIngestionFilePrototypeCsvProperty successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty)
			model.Encoding = core.StringPtr("utf-8")
			model.EscapeCharacter = core.StringPtr("\\\\")
			model.FieldDelimiter = core.StringPtr(",")
			model.Header = core.BoolPtr(true)
			model.LineDelimiter = core.StringPtr("\\n")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.PreviewIngestionFilePrototypeCsvProperty
			err = watsonxdatav2.UnmarshalPreviewIngestionFilePrototypeCsvProperty(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRemoveEngineProperties successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.RemoveEngineProperties)
			model.Catalog = nil
			model.Configuration = nil
			model.Jvm = nil
			model.Velox = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.RemoveEngineProperties
			err = watsonxdatav2.UnmarshalRemoveEngineProperties(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRemoveEnginePropertiesConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.RemoveEnginePropertiesConfiguration)
			model.Coordinator = []string{"testString"}
			model.Worker = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.RemoveEnginePropertiesConfiguration
			err = watsonxdatav2.UnmarshalRemoveEnginePropertiesConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRemoveEnginePropertiesOaiGenConfiguration successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration)
			model.Coordinator = []string{"testString"}
			model.Worker = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.RemoveEnginePropertiesOaiGenConfiguration
			err = watsonxdatav2.UnmarshalRemoveEnginePropertiesOaiGenConfiguration(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalRemoveEnginePropertiesOaiGenJvm successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.RemoveEnginePropertiesOaiGenJvm)
			model.Coordinator = []string{"testString"}
			model.Worker = []string{"testString"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.RemoveEnginePropertiesOaiGenJvm
			err = watsonxdatav2.UnmarshalRemoveEnginePropertiesOaiGenJvm(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkApplicationConfig successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkApplicationConfig)
			model.SparkSampleConfigProperpty = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkApplicationConfig
			err = watsonxdatav2.UnmarshalSparkApplicationConfig(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkApplicationDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkApplicationDetails)
			model.Application = core.StringPtr("s3://mybucket/wordcount.py")
			model.Arguments = []string{"people.txt"}
			model.Class = core.StringPtr("org.apache.spark.examples.SparkPi")
			model.Conf = nil
			model.Env = nil
			model.Files = core.StringPtr("s3://mybucket/myfile.txt")
			model.Jars = core.StringPtr("testString")
			model.Name = core.StringPtr("SparkApplicaton1")
			model.Packages = core.StringPtr("org.apache.spark:example_1.2.3")
			model.Repositories = core.StringPtr("https://repo1.maven.org/maven2/")
			model.SparkVersion = core.StringPtr("3.3")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkApplicationDetails
			err = watsonxdatav2.UnmarshalSparkApplicationDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkApplicationEnv successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkApplicationEnv)
			model.SampleEnvKey = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkApplicationEnv
			err = watsonxdatav2.UnmarshalSparkApplicationEnv(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkDefaultConfig successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkDefaultConfig)
			model.Config1 = core.StringPtr("testString")
			model.Config2 = core.StringPtr("testString")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkDefaultConfig
			err = watsonxdatav2.UnmarshalSparkDefaultConfig(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkEngineDetailsPrototype successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkEngineDetailsPrototype)
			model.ApiKey = core.StringPtr("apikey")
			model.ConnectionString = core.StringPtr("1.2.3.4")
			model.DefaultConfig = nil
			model.DefaultVersion = core.StringPtr("4.8.3")
			model.EngineHomeBucketDisplayName = core.StringPtr("test-spark-bucket")
			model.EngineHomeBucketName = core.StringPtr("test-spark-bucket")
			model.EngineHomePath = core.StringPtr("spark/spark1234")
			model.EngineHomeVolumeID = core.StringPtr("1704979825978585")
			model.EngineHomeVolumeName = core.StringPtr("my-volume")
			model.EngineHomeVolumeStorageClass = core.StringPtr("nfs-client")
			model.EngineHomeVolumeStorageSize = core.StringPtr("5Gi")
			model.InstanceID = core.StringPtr("spark-id")
			model.ManagedBy = core.StringPtr("fully/self")
			model.ScaleConfig = nil

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkEngineDetailsPrototype
			err = watsonxdatav2.UnmarshalSparkEngineDetailsPrototype(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkScaleConfig successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkScaleConfig)
			model.AutoScaleEnabled = core.BoolPtr(true)
			model.CurrentNumberOfNodes = core.Int64Ptr(int64(2))
			model.MaximumNumberOfNodes = core.Int64Ptr(int64(5))
			model.MinimumNumberOfNodes = core.Int64Ptr(int64(1))
			model.NodeType = core.StringPtr("medium")
			model.NumberOfNodes = core.Int64Ptr(int64(2))

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkScaleConfig
			err = watsonxdatav2.UnmarshalSparkScaleConfig(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSparkVolumeDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SparkVolumeDetails)
			model.MountPath = core.StringPtr("/mount/path")
			model.Name = core.StringPtr("my-volume")
			model.ReadOnly = core.BoolPtr(true)
			model.SourceSubPath = core.StringPtr("/source/path")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SparkVolumeDetails
			err = watsonxdatav2.UnmarshalSparkVolumeDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalSyncCatalogs successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.SyncCatalogs)
			model.AutoAddNewTables = core.BoolPtr(true)
			model.SyncIcebergMd = core.BoolPtr(true)

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.SyncCatalogs
			err = watsonxdatav2.UnmarshalSyncCatalogs(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalTablePatch successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.TablePatch)
			model.TableName = core.StringPtr("updated_table_name")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.TablePatch
			err = watsonxdatav2.UnmarshalTablePatch(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalUpdateSparkEngineBody successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.UpdateSparkEngineBody)
			model.Description = core.StringPtr("updated description for spark engine")
			model.EngineDetails = nil
			model.EngineDisplayName = core.StringPtr("sampleEngine")
			model.Tags = []string{"tag1", "tag2"}

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.UpdateSparkEngineBody
			err = watsonxdatav2.UnmarshalUpdateSparkEngineBody(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
		It(`Invoke UnmarshalUpdateSparkEngineBodyEngineDetails successfully`, func() {
			// Construct an instance of the model.
			model := new(watsonxdatav2.UpdateSparkEngineBodyEngineDetails)
			model.DefaultConfig = map[string]string{"key1": "testString"}
			model.DefaultVersion = core.StringPtr("4.8.3")

			b, err := json.Marshal(model)
			Expect(err).To(BeNil())

			var raw map[string]json.RawMessage
			err = json.Unmarshal(b, &raw)
			Expect(err).To(BeNil())

			var result *watsonxdatav2.UpdateSparkEngineBodyEngineDetails
			err = watsonxdatav2.UnmarshalUpdateSparkEngineBodyEngineDetails(raw, &result)
			Expect(err).To(BeNil())
			Expect(result).ToNot(BeNil())
			Expect(result).To(Equal(model))
		})
	})
	Describe(`Utility function tests`, func() {
		It(`Invoke CreateMockByteArray() successfully`, func() {
			mockByteArray := CreateMockByteArray("VGhpcyBpcyBhIHRlc3Qgb2YgdGhlIGVtZXJnZW5jeSBicm9hZGNhc3Qgc3lzdGVt")
			Expect(mockByteArray).ToNot(BeNil())
		})
		It(`Invoke CreateMockUUID() successfully`, func() {
			mockUUID := CreateMockUUID("9fab83da-98cb-4f18-a7ba-b6f0435c9673")
			Expect(mockUUID).ToNot(BeNil())
		})
		It(`Invoke CreateMockReader() successfully`, func() {
			mockReader := CreateMockReader("This is a test.")
			Expect(mockReader).ToNot(BeNil())
		})
		It(`Invoke CreateMockDate() successfully`, func() {
			mockDate := CreateMockDate("2019-01-01")
			Expect(mockDate).ToNot(BeNil())
		})
		It(`Invoke CreateMockDateTime() successfully`, func() {
			mockDateTime := CreateMockDateTime("2019-01-01T12:00:00.000Z")
			Expect(mockDateTime).ToNot(BeNil())
		})
	})
})

//
// Utility functions used by the generated test code
//

func CreateMockByteArray(encodedString string) *[]byte {
	ba, err := base64.StdEncoding.DecodeString(encodedString)
	if err != nil {
		panic(err)
	}
	return &ba
}

func CreateMockUUID(mockData string) *strfmt.UUID {
	uuid := strfmt.UUID(mockData)
	return &uuid
}

func CreateMockReader(mockData string) io.ReadCloser {
	return io.NopCloser(bytes.NewReader([]byte(mockData)))
}

func CreateMockDate(mockData string) *strfmt.Date {
	d, err := core.ParseDate(mockData)
	if err != nil {
		return nil
	}
	return &d
}

func CreateMockDateTime(mockData string) *strfmt.DateTime {
	d, err := core.ParseDateTime(mockData)
	if err != nil {
		return nil
	}
	return &d
}

func SetTestEnvironment(testEnvironment map[string]string) {
	for key, value := range testEnvironment {
		os.Setenv(key, value)
	}
}

func ClearTestEnvironment(testEnvironment map[string]string) {
	for key := range testEnvironment {
		os.Unsetenv(key)
	}
}
